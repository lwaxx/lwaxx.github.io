{"meta":{"title":"Lwaxx的博客","subtitle":"","description":"","author":"李伟","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2022-01-02T07:11:59.000Z","updated":"2022-01-02T07:34:55.580Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"404","date":"2022-01-02T09:01:05.000Z","updated":"2022-01-02T09:03:20.397Z","comments":true,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 Not Found 对不起，您所访问的页面不存在或者已删除 [点击此处](https://kalialbert.github.io/)返回首页 我的Github：https://lwaxx.github.io/"},{"title":"标签","date":"2022-01-02T07:16:29.000Z","updated":"2022-01-09T05:13:57.299Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"冒泡排序算法","slug":"冒泡排序算法","date":"2023-09-10T01:27:48.000Z","updated":"2023-09-10T01:36:56.486Z","comments":true,"path":"2023/09/10/冒泡排序算法/","link":"","permalink":"http://example.com/2023/09/10/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"排序算法是计算机科学中的重要主题，而冒泡排序（Bubble Sort）则是最简单的排序算法之一。尽管它在大型数据集上效率较低，但它的工作原理非常直观，是理解排序算法的绝佳起点。本文将深入探讨冒泡排序的工作原理、时间复杂度以及应用场景。","text":"排序算法是计算机科学中的重要主题，而冒泡排序（Bubble Sort）则是最简单的排序算法之一。尽管它在大型数据集上效率较低，但它的工作原理非常直观，是理解排序算法的绝佳起点。本文将深入探讨冒泡排序的工作原理、时间复杂度以及应用场景。 冒泡排序的基本思想冒泡排序的基本思想非常简单：通过不断比较相邻的两个元素，如果它们的顺序不正确，就交换它们，直到整个数组都排好序。这个过程类似于气泡在液体中上浮的过程，因此得名冒泡排序。 让我们通过一个简单的示例来理解冒泡排序的工作原理。假设有一个整数数组 [5, 2, 9, 3, 4]，我们希望按升序排序它。1.第一次冒泡： 从数组的起始位置开始，比较相邻的元素，即 5 和 2。因为 5 &gt; 2，所以它们的顺序不正确，需要交换它们。数组变为 [2, 5, 9, 3, 4]。2.第二次冒泡： 接下来，比较 5 和 9。由于它们的顺序正确，不需要交换。数组保持不变。3.第三次冒泡： 继续比较 9 和 3，发现它们的顺序不正确，需要交换。数组变为 [2, 5, 3, 9, 4]。4.第四次冒泡： 最后，比较 9 和 4，同样发现它们的顺序不正确，需要交换。数组变为 [2, 5, 3, 4, 9]。 这个过程会不断迭代，每次迭代都会将最大的元素“冒泡”到数组的末尾。在一次迭代中，通过多次比较和交换，最大的元素将沿着数组一路上浮到正确的位置。这就是为什么它被称为“冒泡”排序。 冒泡排序的时间复杂度虽然冒泡排序的思想简单，但它的时间复杂度并不理想。在最坏情况下，冒泡排序需要进行 n-1 次迭代（n 为数组长度），每次迭代都要比较相邻的元素并进行交换。因此，最坏情况下的时间复杂度为 O(n^2)。这使得冒泡排序在处理大型数据集时效率较低。 值得注意的是，在最佳情况下（数组已经有序），冒泡排序只需要一次迭代，因此时间复杂度为 O(n)。但这种情况很少发生。 冒泡排序的应用场景冒泡排序的性能相对较差，通常不推荐在实际应用中使用，特别是对于大型数据集。然而，由于其简单的原理，冒泡排序仍然有一些应用场景： 1.教育和学习： 冒泡排序是教授排序算法的良好起点，因为它易于理解和实现。2.小型数据集： 在处理小型数据集时，冒泡排序的性能可能比其他复杂的排序算法更好。3.已接近有序的数据： 如果数据集已经基本有序，冒泡排序可能比其他算法更有效。4.排序算法的可视化： 冒泡排序可以用于排序算法可视化工具，帮助人们更好地理解排序过程。 代码示例以下是冒泡排序的示例代码，分别使用Python、Go、Java和C语言编写。 python代码 12345678910def bubble_sort(arr): n = len(arr) for i in range(n): for j in range(0, n-i-1): if arr[j] &gt; arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j]arr = [5, 2, 9, 3, 4]bubble_sort(arr)print(&quot;排序后的数组:&quot;, arr) Go代码 1234567891011121314151617181920package mainimport &quot;fmt&quot;func bubbleSort(arr []int) &#123; n := len(arr) for i := 0; i &lt; n; i++ &#123; for j := 0; j &lt; n-i-1; j++ &#123; if arr[j] &gt; arr[j+1] &#123; arr[j], arr[j+1] = arr[j+1], arr[j] &#125; &#125; &#125;&#125;func main() &#123; arr := []int&#123;5, 2, 9, 3, 4&#125; bubbleSort(arr) fmt.Println(&quot;排序后的数组:&quot;, arr)&#125; java代码 1234567891011121314151617181920212223public class BubbleSort &#123; public static void bubbleSort(int[] arr) &#123; int n = arr.length; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] arr = &#123;5, 2, 9, 3, 4&#125;; bubbleSort(arr); System.out.print(&quot;排序后的数组: &quot;); for (int num : arr) &#123; System.out.print(num + &quot; &quot;); &#125; &#125;&#125; C代码 123456789101112131415161718192021222324#include &lt;stdio.h&gt;void bubbleSort(int arr[], int n) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125;int main() &#123; int arr[] = &#123;5, 2, 9, 3, 4&#125;; int n = sizeof(arr) / sizeof(arr[0]); bubbleSort(arr, n); printf(&quot;排序后的数组: &quot;); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, arr[i]); &#125; return 0;&#125; 这些示例代码展示了如何使用不同编程语言编写冒泡排序算法，它们都具有相同的工作原理，只是语法有所不同。冒泡排序是一种简单但不够高效的排序算法，通常在实际应用中使用更高效的排序算法。 结论冒泡排序虽然不是最高效的排序算法，但它的简单性和直观性使它成为学习排序算法的良好起点。在实际应用中，通常会选择更高效的排序算法，特别是对于大型数据集。然而，了解冒泡排序的工作原理有助于理解更复杂的排序算法，并为算法设计提供宝贵的启示。","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"算法/排序算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"解析排序算法：十大排序方法的工作原理与性能比较","slug":"解析排序算法：十大排序方法的工作原理与性能比较","date":"2023-09-10T01:17:10.000Z","updated":"2023-09-10T01:25:51.924Z","comments":true,"path":"2023/09/10/解析排序算法：十大排序方法的工作原理与性能比较/","link":"","permalink":"http://example.com/2023/09/10/%E8%A7%A3%E6%9E%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/","excerpt":"当我们面临对数据进行排序的任务时，计算机科学家们开发了多种排序算法来满足不同的需求。这些排序算法各具特点，适用于不同规模和类型的数据集。在本文中，我们将介绍十大常见的排序算法，并讨论它们的工作原理、时间复杂度以及适用场景。","text":"当我们面临对数据进行排序的任务时，计算机科学家们开发了多种排序算法来满足不同的需求。这些排序算法各具特点，适用于不同规模和类型的数据集。在本文中，我们将介绍十大常见的排序算法，并讨论它们的工作原理、时间复杂度以及适用场景。 1. 冒泡排序（Bubble Sort）冒泡排序是最简单的排序算法之一。它反复比较相邻的两个元素，如果它们的顺序不正确，就交换它们，直到整个数组都排好序。冒泡排序的时间复杂度为O(n^2)，适用于小型数据集，但在大型数据集上效率较低。 2. 选择排序（Selection Sort）选择排序将数组分为已排序和未排序两部分，然后选择未排序部分中的最小（或最大）元素，将其放在已排序部分的末尾。选择排序的时间复杂度也是O(n^2)，不稳定，适用于小型数据集。 3. 插入排序（Insertion Sort）插入排序将数组分为已排序和未排序两部分，然后逐个将未排序部分的元素插入已排序部分的正确位置。插入排序的时间复杂度也是O(n^2)，但在某些情况下比冒泡和选择排序更快，特别适用于部分有序的数据。 4. 快速排序（Quick Sort）快速排序是一种高效的分治排序算法。它选择一个元素作为“pivot”（基准），将数组分成两部分，然后递归地对这两部分进行排序。快速排序的平均时间复杂度为O(n*log(n))，但在最坏情况下可能达到O(n^2)。 5. 归并排序（Merge Sort）归并排序也是一种分治排序算法，它将数组逐步分成较小的子数组，然后合并这些子数组以获取最终排序结果。归并排序的时间复杂度为O(n*log(n))，具有稳定性。 6. 堆排序（Heap Sort）堆排序使用堆数据结构进行排序。它将数组看作二叉树，构建一个最大堆（或最小堆），然后逐个从堆中取出元素，得到有序序列。堆排序的时间复杂度为O(n*log(n))，不稳定。 7. 计数排序（Counting Sort）计数排序是一种非比较排序算法，适用于整数数据范围较小的情况。它通过统计每个元素出现的次数来进行排序，然后根据计数重新构建有序数组。时间复杂度为O(n+k)，其中k是整数范围。 8. 桶排序（Bucket Sort）桶排序也是一种非比较排序算法，它将数据分为若干个桶，然后对每个桶内的数据进行排序，最后合并桶。桶排序适用于数据分布均匀的情况，平均时间复杂度为O(n+k)，其中k是桶的数量。 9. 基数排序（Radix Sort）基数排序是一种非比较排序算法，适用于整数或字符串排序。它按照元素的位数从低位到高位依次排序，每次排序使用稳定的排序算法。时间复杂度为O(d*(n+k))，其中d是最大位数，k是基数。 10. 希尔排序（Shell Sort）希尔排序是一种改进的插入排序算法，它将数组分为若干个子序列，分别进行插入排序，然后逐渐减小子序列的间隔，最终完成排序。希尔排序的时间复杂度取决于间隔序列的选择，平均时间复杂度介于O(n*log(n))和O(n^2)之间。 每种排序算法都有其独特的优势和限制，选择合适的排序算法应根据数据集的规模、数据分布和性能需求来决定。了解这些排序算法的工作原理和特点可以帮助我们在实际应用中做出明智的选择，以满足不同排序任务的需求。无论是对小型数据集进行快速排序还是对大型数据集进行稳定排序，这十大排序算法都为我们提供了多种选择。","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"算法/排序算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"python列表删除元素(全)","slug":"python列表删除元素-全","date":"2022-09-29T09:54:45.000Z","updated":"2023-09-10T02:28:44.475Z","comments":true,"path":"2022/09/29/python列表删除元素-全/","link":"","permalink":"http://example.com/2022/09/29/python%E5%88%97%E8%A1%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-%E5%85%A8/","excerpt":"python列表删除元素","text":"python列表删除元素 列表直接删除元素remove: 删除单个元素，删除首个符合条件的元素，按值删除 123str = [1,2,3,4,3,5,6,2]str.remove(3)print(str) # [1, 2, 4, 3, 5, 6, 2] pop: 删除单个或多个元素，按位删除(根据索引删除), 删除时会返回被删除的元素 123str_pop= [1,2,3,4,3,5,6,2]str_pop.pop(3)print(str_pop) # [1, 2, 3, 3, 5, 6, 2] del: 根据索引删除 123str_del= [1,2,3,4,3,5,6,2]del str_del[1]print(str_del) # [1, 3, 4, 3, 5, 6, 2] 列表遍历过程中删除元素, 会造成不可预知错误, 可使用下面几种方法删除方法一: 列表推导式 1234# 删除 &lt;4list1 = [1, 2, 3, 4, 5, 6]new_list1 = [i for i in list1 if i &gt; 4]print(new_list1) 方法二: filter + lambda 1234# 删除 &lt;4list2 = [1, 2, 3, 4, 5, 6]new_list2 = filter(lambda i: i &gt; 4, list2)print(list(new_list2)) 方法三: 倒序遍历 123456# 删除 &gt;4list3 = [1, 2, 3, 4, 5, 6]for i in range(len(list3)-1, -1, -1): if list3[i] &gt; 4: list3.remove(list3[i])print(list3) 方法四: 1234567# 删除 &gt;4list4 = [1, 2, 3, 4, 5, 6]new_list4 = []for i in list4: if i &lt;= 4: new_list4.append(i)print(new_list4)","categories":[],"tags":[]},{"title":"go语言数组相关","slug":"go语言数组相关","date":"2022-08-11T03:53:52.000Z","updated":"2023-09-10T02:28:44.474Z","comments":true,"path":"2022/08/11/go语言数组相关/","link":"","permalink":"http://example.com/2022/08/11/go%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/","excerpt":"go语言数组相关换算目前已有：交集，差集，去重持续更新","text":"go语言数组相关换算目前已有：交集，差集，去重持续更新 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package main// 数组相关换算// 交集，差集，去重import ( &quot;fmt&quot;)func main() &#123; a := []int&#123;98, 298, 588, 1598, 3698, 5000&#125; b := []int&#123;298, 588&#125; // DiffArray 求两个切片的差集, 在a里面不在b里面 diff_array := DiffArray(a, b) fmt.Println(diff_array) // 交集 intersect_array := IntersectArray(a, b) fmt.Println(intersect_array) // 去重 arr := []string&#123;&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125; remove_repeated := RemoveRepeatedElement(arr) remove_repeatedq := arrayUnique(arr) fmt.Println(remove_repeated) fmt.Println(remove_repeatedq)&#125;// DiffArray 求两个切片的差集func DiffArray(a []int, b []int) []int &#123; var diffArray []int temp := map[int]struct&#123;&#125;&#123;&#125; for _, val := range b &#123; if _, ok := temp[val]; !ok &#123; temp[val] = struct&#123;&#125;&#123;&#125; &#125; &#125; for _, val := range a &#123; if _, ok := temp[val]; !ok &#123; diffArray = append(diffArray, val) &#125; &#125; return diffArray&#125;// IntersectArray 求两个切片的交集func IntersectArray(a []int, b []int) []int &#123; var inter []int mp := make(map[int]bool) for _, s := range a &#123; if _, ok := mp[s]; !ok &#123; mp[s] = true &#125; &#125; for _, s := range b &#123; if _, ok := mp[s]; ok &#123; inter = append(inter, s) &#125; &#125; return inter&#125;//切片去重实现func arrayUnique(arr []string) []string &#123; result := make([]string, 0, len(arr)) temp := map[string]struct&#123;&#125;&#123;&#125; for i := 0; i &lt; len(arr); i++ &#123; if _, ok := temp[arr[i]]; ok != true &#123; temp[arr[i]] = struct&#123;&#125;&#123;&#125; result = append(result, arr[i]) &#125; &#125; return result&#125;// RemoveRepeatedElement 切片去重实现func RemoveRepeatedElement(arr []string) (newArr []string) &#123; newArr = make([]string, 0) for i := 0; i &lt; len(arr); i++ &#123; repeat := false for j := i + 1; j &lt; len(arr); j++ &#123; if arr[i] == arr[j] &#123; repeat = true break &#125; &#125; if !repeat &#123; newArr = append(newArr, arr[i]) &#125; &#125; return&#125;","categories":[{"name":"golang开发","slug":"golang开发","permalink":"http://example.com/categories/golang%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://example.com/tags/Go/"}]},{"title":"go语言除法四舍五入","slug":"go语言除法四舍五入","date":"2022-05-18T08:03:13.000Z","updated":"2023-09-10T02:28:44.475Z","comments":true,"path":"2022/05/18/go语言除法四舍五入/","link":"","permalink":"http://example.com/2022/05/18/go%E8%AF%AD%E8%A8%80%E9%99%A4%E6%B3%95%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5/","excerpt":"加0.5后向下取整","text":"加0.5后向下取整 123func round(x float64) int64 &#123; return int64(math.Floor(x + 0.5))&#125;","categories":[{"name":"后端开发","slug":"后端开发","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://example.com/tags/Go/"}]},{"title":"python时间格式化/时间格式转换","slug":"python时间格式化-时间格式转换","date":"2022-03-09T07:29:40.000Z","updated":"2023-09-10T02:28:44.476Z","comments":true,"path":"2022/03/09/python时间格式化-时间格式转换/","link":"","permalink":"http://example.com/2022/03/09/python%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96-%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/","excerpt":"python时间格式化/时间格式转换","text":"python时间格式化/时间格式转换 12345678910111213141516171819202122232425262728293031&quot;&quot;&quot;获取某个时间&quot;&quot;&quot;import datetimeimport timefrom dateutil import relativedelta# 上月(eg: 202201)last_month = (datetime.datetime.now() + relativedelta.relativedelta(months=-1)).strftime(&quot;%Y%m&quot;)# 当月(eg: 202202)issue_no = time.strftime(&quot;%Y%m&quot;)# 下月(eg: 202203)nextmonth = (datetime.date.today() + relativedelta.relativedelta(months=1)).strftime(&quot;%Y%m&quot;)# 年月日（eg:2022-03-01）now = datetime.datetime.now().strftime(&#x27;%Y-%m-%d&#x27;)now = datetime.datetime.now().strftime(&quot;%Y%m%d&quot;)# 年月日时分秒（eg:2022-03-01 00:00:00）now = datetime.datetime.now().strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;)# 当月第一天，下月第一天month_first_day = datetime.date(year=today.year, month=today.month, day=1)next_clear_day = month_first_day + relativedelta(months=1)# 3天前的日期 threeDayAgo = (datetime.datetime.now() - datetime.timedelta(days = 3)) # 31天后的日期starttime = datetime.datetime.now().strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;)endtime = (datetime.datetime.now() + datetime.timedelta(days=31)).strftime(&#x27;%Y-%m-%d 00:00:00&#x27;) 1234567891011121314151617181920212223242526272829303132&quot;&quot;&quot;时间转换&quot;&quot;&quot;import timeimport datetime# 时间戳转字符串格式时间timestamp = time.time() # 当前时间戳strtime = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime(timestamp))# 字符串格式时间转时间戳now_str = &quot;2022-03-09 00:00:00&quot;now_time = time.strptime(now_str,&#x27;%Y-%m-%d %H:%M:%S&#x27;)timestamp = time.mktime(now_time)# 当前时间30分钟后时间日期，35分钟后时间日期start_time1 = (datetime.datetime.now()+datetime.timedelta(minutes=30)).strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)end_time1 = (datetime.datetime.now()+datetime.timedelta(minutes=30)+datetime.timedelta(minutes=5)).strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)print(start_time1)print(end_time1)# 下周一零点today = datetime.datetime.today()wd = today.weekday() # 周几，从0开始算next_monday = datetime.datetime(today.year, today.month, today.day) + datetime.timedelta(days=7-wd)print(today)print(wd)print(next_monday)# 24小时之后的时间expire = today + datetime.timedelta(hours=24)print(expire) 12# python日期格式化week = time.strftime(&quot;%A&quot;) 附：python日期格式化符号%y 两位数的年份表示（00-99）%Y 四位数的年份表示（000-9999）%m 月份（01-12）%d 月内中的一天（0-31）%H 24小时制小时数（0-23）%I 12小时制小时数（01-12）%M 分钟数（00=59）%S 秒（00-59）%a 本地简化星期名称%A 本地完整星期名称%b 本地简化的月份名称%B 本地完整的月份名称%c 本地相应的日期表示和时间表示%j 年内的一天（001-366）%p 本地A.M.或P.M.的等价符%U 一年中的星期数（00-53）星期天为星期的开始%w 星期（0-6），星期天为星期的开始%W 一年中的星期数（00-53）星期一为星期的开始%x 本地相应的日期表示%X 本地相应的时间表示%Z 当前时区的名称%% %号本身","categories":[{"name":"后端开发","slug":"后端开发","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"工作中常用到的github命令","slug":"工作中常用到的github命令","date":"2022-03-02T08:05:06.000Z","updated":"2022-03-06T02:31:20.306Z","comments":true,"path":"2022/03/02/工作中常用到的github命令/","link":"","permalink":"http://example.com/2022/03/02/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%88%B0%E7%9A%84github%E5%91%BD%E4%BB%A4/","excerpt":"工作中常用到的github命令","text":"工作中常用到的github命令 从master新建分支 1.git checkout master 切换到master分支2.git pull 更新到最新代码3.git checkout -b dev 创建新分支并切换到该分支4.git push origin dev 推送新分支到远程仓库5.git branch –set-upstream-to=origin/dev 关联远程仓库6.git pull 尝试拉取验证 dev分支合并代码到master 1.git checkout maste;2.git pull origin master;3.git merge –squash dev;4.git status;5.git stash; (暂存起来，查看解决的冲突有没有问题)6.git stash pop;7.git diff; (确认没问题，直接添加)8.git add .;9.git commit -m “feat: xxxx”;10.git log;11.git push origin master; git rebase（dev–自己， master–想要比对的） 1.dev和master分支先更新到最新，然后切换到dev分支；2.git log;3.git rebase master;4.git status;5.解决冲突;6.git add [冲突文件]；7.git rebase –continue;8.:wq（保存）9.继续git status; (重复知道所有冲突解决完)10.git rebase -i [commit名称（dev分支第一次commit之前的名称，非自己的）];11.将前面的pick改为f（除了第一次commit的);","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"}]},{"title":"百度搜索爬取图片","slug":"百度搜索爬取图片","date":"2022-01-12T11:11:33.000Z","updated":"2022-03-06T02:31:20.306Z","comments":true,"path":"2022/01/12/百度搜索爬取图片/","link":"","permalink":"http://example.com/2022/01/12/%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E7%88%AC%E5%8F%96%E5%9B%BE%E7%89%87/","excerpt":"根据百度搜索内容爬取图片","text":"根据百度搜索内容爬取图片 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# coding=utf-8&quot;&quot;&quot;根据搜索词下载百度图片&quot;&quot;&quot;import reimport sysimport urllibimport os import requests def getPage(keyword,page,n): page=page*n keyword=urllib.parse.quote(keyword, safe=&#x27;/&#x27;) url_begin= &quot;http://image.baidu.com/search/flip?tn=baiduimage&amp;ie=utf-8&amp;word=&quot; url = url_begin+ keyword + &quot;&amp;pn=&quot; +str(page) + &quot;&amp;gsm=&quot;+str(hex(page))+&quot;&amp;ct=&amp;ic=0&amp;lm=-1&amp;width=0&amp;height=0&quot; return url def get_onepage_urls(onepageurl): try: html = requests.get(onepageurl).text except Exception as e: print(e) pic_urls = [] return pic_urls pic_urls = re.findall(&#x27;&quot;objURL&quot;:&quot;(.*?)&quot;,&#x27;, html, re.S) return pic_urls def down_pic(pic_urls, keyword): &quot;&quot;&quot;给出图片链接列表, 下载所有图片&quot;&quot;&quot; for i, pic_url in enumerate(pic_urls): try: pic = requests.get(pic_url, timeout=15) string =str(i + 1) + &#x27;.jpg&#x27; if os.path.exists(&#x27;./&#x27; + keyword): with open(&#x27;./&#x27; + keyword + &#x27;/&#x27; + string, &#x27;wb&#x27;) as f: f.write(pic.content) print(&#x27;成功下载第%s张图片: %s&#x27; % (str(i + 1), str(pic_url))) else: os.mkdir(&#x27;./&#x27; + keyword) with open(&#x27;./&#x27; + keyword + &#x27;/&#x27; + string, &#x27;wb&#x27;) as f: f.write(pic.content) print(&#x27;成功下载第%s张图片: %s&#x27; % (str(i + 1), str(pic_url))) except Exception as e: print(&#x27;下载第%s张图片时失败: %s&#x27; % (str(i + 1), str(pic_url))) print(e) continue if __name__ == &#x27;__main__&#x27;: keyword = &#x27;天海翼&#x27; # 关键词, 改为你想输入的词即可, 相当于在百度图片里搜索一样 page_begin=0 page_number=30 image_number=3 all_pic_urls = [] while 1: if page_begin&gt;image_number: break print(&quot;第%d次请求数据&quot;,[page_begin]) url=getPage(keyword,page_begin,page_number) onepage_urls= get_onepage_urls(url) page_begin += 1 all_pic_urls.extend(onepage_urls) down_pic(list(set(all_pic_urls)), keyword)","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"mysql批量插入数据 excutemany","slug":"mysql批量插入数据-excutemany","date":"2022-01-04T03:25:31.000Z","updated":"2022-01-09T05:13:57.279Z","comments":true,"path":"2022/01/04/mysql批量插入数据-excutemany/","link":"","permalink":"http://example.com/2022/01/04/mysql%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-excutemany/","excerpt":"问题：往数据库批量插入10条数据的时候，在for循环里面使用excute插入，接口请求耗时&gt;1s，严重影响效率；","text":"问题：往数据库批量插入10条数据的时候，在for循环里面使用excute插入，接口请求耗时&gt;1s，严重影响效率； 遂考虑使用excutemany批量插入，接口请求耗时400ms 逐条插入：cursor.excute()批量插入：cursor.excutemany()使用：executemany(templet, args)templet：sql模板字符串，例如：insert into table(id,name) values(%s,%s)args: 模板字符串中的参数，是一个list或者tuple, eg: [(1,”a”),(2,”b”)] 或者 ((1,”a”),(2,”b”)) 123456789101112# 实例-节选import timedraw_list = [...] # len(draw_list) = 10sql = &#x27;&#x27;&#x27; insert into table(remix_uid, stage, tp, price, draw_result) values (%s,%s,%s,%s,%s)&#x27;&#x27;&#x27;cursor = db.cursor()start_time = time.time()for i in draw_list: cursor.excute(sql, [args])end_time = time.time() - start_timeprint(end_time) # &gt;1s 修改为以下： 12345678cursor = db.cursor()start_time = time.time()data = ((item[&#x27;&#x27;], item[&#x27;&#x27;], ...) for item in draw_list)cursor.executemany(sql, data)end_time = time.time() - start_timeprint(end_time) # 400ms","categories":[{"name":"后端开发","slug":"后端开发","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"},{"name":"Databse","slug":"Databse","permalink":"http://example.com/tags/Databse/"}]},{"title":"python时间时间换算 精确到毫秒","slug":"python时间时间换算-精确到毫秒","date":"2022-01-04T03:23:41.000Z","updated":"2022-01-09T05:13:57.296Z","comments":true,"path":"2022/01/04/python时间时间换算-精确到毫秒/","link":"","permalink":"http://example.com/2022/01/04/python%E6%97%B6%E9%97%B4%E6%97%B6%E9%97%B4%E6%8D%A2%E7%AE%97-%E7%B2%BE%E7%A1%AE%E5%88%B0%E6%AF%AB%E7%A7%92/","excerpt":"python时间时间换算 精确到毫秒","text":"python时间时间换算 精确到毫秒 123456789101112131415import timeimport datetimedef time_stamp1(): &quot;&quot;&quot; 时间戳 精确到毫秒，17位 :return: &quot;&quot;&quot; ct = time.time() local_time = time.localtime(ct) data_head = time.strftime(&quot;%Y%m%d%H%M%S&quot;, local_time) data_secs = (ct - int(ct)) * 1000 time_stamp = &quot;%s%03d&quot; % (data_head, data_secs) # 17位时间戳 return time_stamp 12345678def time_stamp2(): &quot;&quot;&quot; 时间戳 精确到毫秒，20位 :return: &quot;&quot;&quot; time = datetime.datetime.now().strftime(&#x27;%Y%m%d%H%M%S%f&#x27;) # 20位时间戳 random_digit = &#x27;&#x27;.join(str(random.choice(range(8))) for _ in range(8)) # 8位随机数 return (time+random_digit)","categories":[{"name":"后端开发","slug":"后端开发","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Go语言生成随机数","slug":"Go语言生成随机数","date":"2022-01-04T03:22:24.000Z","updated":"2023-09-10T02:28:44.474Z","comments":true,"path":"2022/01/04/Go语言生成随机数/","link":"","permalink":"http://example.com/2022/01/04/Go%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/","excerpt":"使用go语言生成随机数","text":"使用go语言生成随机数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package mainimport ( &quot;fmt&quot; &quot;math/rand&quot; &quot;time&quot;)func main() &#123; // 由于go语言未提供2个区间参数，只一个参数的情况下先随机0到(m-n)，再用加 n 的方式解决 // 例：[5, 10], 先生成[0,5], 再加5 // go取随机数需要指定一个随机种子 // 种子一般使用当前的系统时间，这是完全随机的。 for i := 0; i &lt; 50; i++ &#123; // res := getRandomWithAll(5, 10) // res := getRandomWithMin(5, 10) // res := getRandomWithMax(5, 10) res := getRandomWithNo(5, 10) fmt.Println(res) &#125;&#125;// 包含上下限 [min, max]func getRandomWithAll(min, max int) int64 &#123; rand.Seed(time.Now().UnixNano()) return int64(rand.Intn(max-min+1) + min)&#125;// 不包含上限 [min, max)func getRandomWithMin(min, max int) int64 &#123; rand.Seed(time.Now().UnixNano()) return int64(rand.Intn(max-min) + min)&#125;// 不包含下限 (min, max]func getRandomWithMax(min, max int) int64 &#123; var res int64 rand.Seed(time.Now().UnixNano())Restart: res = int64(rand.Intn(max-min+1) + min) if res == int64(min) &#123; goto Restart &#125; return res&#125;// 都不包含 (min, max)func getRandomWithNo(min, max int) int64 &#123; var res int64 rand.Seed(time.Now().UnixNano())Restart: res = int64(rand.Intn(max-min) + min) if res == int64(min) &#123; goto Restart &#125; return res&#125;","categories":[{"name":"后端开发","slug":"后端开发","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://example.com/tags/Go/"}]},{"title":"GO语言时间转换","slug":"GO语言时间转换","date":"2022-01-04T03:19:53.000Z","updated":"2023-09-10T02:28:44.473Z","comments":true,"path":"2022/01/04/GO语言时间转换/","link":"","permalink":"http://example.com/2022/01/04/GO%E8%AF%AD%E8%A8%80%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/","excerpt":"使用go语言进行不同时间类型之间的转换","text":"使用go语言进行不同时间类型之间的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; // 2021-07-23 15:36:00.346234 +0800 CST m=+0.000174001 now := time.Now() // 格式化 2021-07-23 15:36:00 time1 := time.Now().Format(&quot;2006-01-02 15:04:05&quot;) // unix时间戳格式化 time2 := now.Unix() // 1627025820 time3 := time.Unix(time2, 0).Format(&quot;2006-01-02 15:04:05&quot;) // 2021-07-23 15:37:00 // 当前时间加/减一分钟 time4 := now.Add(time.Minute * time.Duration(1)) time5 := now.Add(-(time.Minute * time.Duration(1))) // 时间比较大小，先转为以下格式 // 1970-01-01 08:00:00 +0800 CST time6, _ := time.ParseInLocation(&quot;2006-01-02 15:04:05&quot;, time3, time.Local) if now.Before(time6) &#123; fmt.Println(&quot;true&quot;) &#125; else if now.After(time6) &#123; fmt.Println(&quot;false&quot;) &#125; // 周一 on_monday, next_monday := getBgnEnd(now) fmt.Println(on_monday, next_monday) // 下月1号零点 next_month_0 := GetNextMonthStartTs() fmt.Println(next_month_0) // 本月1号零点 on_month_0 := GetFirstDateOfMonth(now) fmt.Println(on_month_0)&#125;//返回周一的字符串和下周一零点的字符串func getBgnEnd(curT time.Time) (string, string) &#123; curW := int(curT.Weekday()) - 1 if curW == -1 &#123; //星期天当成7 curW = 6 &#125; curM := curT.AddDate(0, 0, -curW) tmpMondayTime := time.Date(curM.Year(), curM.Month(), curM.Day(), 0, 0, 0, 0, time.Local).Format(&quot;2006-01-02 15:04:05&quot;) tmpMondayStr := curM.Format(&quot;20060102&quot;) tmpT, _ := time.ParseInLocation(&quot;20060102&quot;, tmpMondayStr, time.Local) tmpDeadLineTime := tmpT.AddDate(0, 0, 7).Format(&quot;2006-01-02 15:04:05&quot;) return tmpMondayTime, tmpDeadLineTime&#125;//返回周一的字符串和下周一零点的时间func getBgnEnd1(curT time.Time) (string, time.Time) &#123; // 一天滚一次 tmpDayStr := curT.Format(&quot;20060102&quot;) tmpT, _ := time.ParseInLocation(&quot;20060102&quot;, tmpDayStr, time.Local) tmpDeadLineTime := tmpT.AddDate(0, 0, 1) return tmpDayStr, tmpDeadLineTime&#125;// 下月1号零点func GetNextMonthStartTs() time.Time &#123; now := time.Now() nowYeah, nowMonth, _ := now.Date() loc := now.Location() return time.Date(nowYeah, nowMonth, 1, 0, 0, 0, 0, loc).AddDate(0, 1, 0)&#125;// 本月1号零点func GetFirstDateOfMonth(d time.Time) time.Time &#123; d = d.AddDate(0, 0, -d.Day()+1) return GetZeroTime(d)&#125;//获取某一天的0点时间func GetZeroTime(d time.Time) time.Time &#123; return time.Date(d.Year(), d.Month(), d.Day(), 0, 0, 0, 0, d.Location())&#125;","categories":[{"name":"后端开发","slug":"后端开发","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://example.com/tags/Go/"}]},{"title":"获取指定范围符合正态分布的随机数Go/Python","slug":"获取指定范围符合正态分布的随机数Go-Python","date":"2022-01-04T02:47:08.000Z","updated":"2022-01-09T05:13:57.298Z","comments":true,"path":"2022/01/04/获取指定范围符合正态分布的随机数Go-Python/","link":"","permalink":"http://example.com/2022/01/04/%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E8%8C%83%E5%9B%B4%E7%AC%A6%E5%90%88%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0Go-Python/","excerpt":"Box-Muller算法 当x和y是两个独立且服从（0，1）均匀分布的随机变量时，有： Z1 = cos(2\\pi x)*\\sqrt{-2ln(1-y))} Z2 = sin(2\\pi x)*\\sqrt{-2ln(1-y))} Z1和Z2独立且服从标准正态分布，当带入均值和方差时: Z = Z1(Z2)*\\sigma +\\mu","text":"Box-Muller算法 当x和y是两个独立且服从（0，1）均匀分布的随机变量时，有： Z1 = cos(2\\pi x)*\\sqrt{-2ln(1-y))} Z2 = sin(2\\pi x)*\\sqrt{-2ln(1-y))} Z1和Z2独立且服从标准正态分布，当带入均值和方差时: Z = Z1(Z2)*\\sigma +\\mu ​均值sigma，标准差mu计算: 根据正态分布的 3sigma法则，5-10范围的均值和方差，和[5,6,7,8,9,10]差不多故：5-10范围的均值：(5+10)/2=7.5标准差：(10-7.5)/3s = [5,6,7,8,9,10]mu = np.mean(s) # 均值sigma = np.std(s) # 标准差var = np.var(s) # 方差 go生成符合正态分布随机数： 123456789101112131415161718192021222324import ( &quot;fmt&quot; &quot;math&quot; &quot;math/rand&quot; &quot;time&quot;)func GetGaussRandomNum(min, max int64) int64 &#123; σ := (float64(min) + float64(max)) / 2 μ := (float64(max) - σ) / 3 rand.Seed(time.Now().UnixNano()) x := rand.Float64() x1 := rand.Float64() a := math.Cos(2*math.Pi*x) * math.Sqrt((-2)*math.Log(x1)) result := a*μ + σ return int64(result)&#125;func main() &#123; for i := 1; i &lt; 1000; i++ &#123; result := GetGaussRandomNum(30, 60) fmt.Println(result) &#125;&#125; python生成符合正态分布随机数： 123456789101112131415161718192021222324252627import numpy as npimport seaborn as snsimport matplotlib.pyplot as pltimport random# 方法一def getGaussRandomNum(min, max): # 比如 生成 50-100 范围内的正态分布的数，均值为75 # 据 3 sigma 法则，取标准差为 （100-75）/3 = 8.33 # mu, sigma = 75, 8.33 # 30-60 mu=45 sig=(60-45)/3=5 mu = (min + max) / 2 sigma = (max - mu) / 3 s = np.random.normal(mu, sigma, 1) return int(s) # sns.set_palette(&quot;hls&quot;) #设置所有图的颜色，使用hls色彩空间 # sns.distplot(s,color=&quot;r&quot;,bins=1000,kde=True) #绘制直方图，color设置颜色，bins设置直方图的划分数 # plt.show() #显示验证结果# 方法二def getGaussRandomNum1(min, max): mu = (min + max) / 2 sigma = (max - mu) / 3 s = random.gauss(mu, sigma) return int(s)","categories":[{"name":"后端开发","slug":"后端开发","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://example.com/tags/Go/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-01-03T13:55:03.151Z","updated":"2022-01-02T07:46:27.715Z","comments":true,"path":"2022/01/03/hello-world/","link":"","permalink":"http://example.com/2022/01/03/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"算法/排序算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"golang开发","slug":"golang开发","permalink":"http://example.com/categories/golang%E5%BC%80%E5%8F%91/"},{"name":"后端开发","slug":"后端开发","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://example.com/tags/Go/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"},{"name":"Databse","slug":"Databse","permalink":"http://example.com/tags/Databse/"}]}