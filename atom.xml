<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lwaxx的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-05-18T07:37:31.242Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>李伟</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入了解MySQL内存管理：如何查看MySQL使用的内存</title>
    <link href="http://example.com/2024/05/18/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3MySQL%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8BMySQL%E4%BD%BF%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98/"/>
    <id>http://example.com/2024/05/18/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3MySQL%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8BMySQL%E4%BD%BF%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98/</id>
    <published>2024-05-18T07:27:45.000Z</published>
    <updated>2024-05-18T07:37:31.242Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：MySQL是一种流行的关系型数据库管理系统，有效管理其内存对于系统的性能和稳定性至关重要。本文将介绍如何查看MySQL使用的内存，包括常见的内存组件和工具，以及如何通过监控和调优来优化MySQL的内存使用。</p><span id="more"></span><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>MySQL是一个开源的关系型数据库管理系统，被广泛应用于各种类型的应用程序中。在MySQL中，内存扮演着至关重要的角色，它用于缓存数据、执行查询、管理连接和执行其他各种任务。因此，有效管理MySQL的内存对于系统的性能和稳定性至关重要。本文将深入探讨如何查看MySQL使用的内存，并提供多个实例来帮助读者更好地理解和应用这一技术。</p><h3 id="1-查看全局内存状态"><a href="#1-查看全局内存状态" class="headerlink" title="1. 查看全局内存状态"></a>1. 查看全局内存状态</h3><p>MySQL提供了一个名为SHOW GLOBAL STATUS的命令，用于查看各种全局状态变量，包括内存相关的状态。你可以使用这个命令来查看MySQL使用的总内存量以及各种内存组件的使用情况。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;memory%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这个命令将返回各种与内存相关的全局状态变量，如memory_used、memory_allocated等，可以帮助你了解MySQL当前使用的内存情况。</p><h3 id="2-查看各个内存组件的状态"><a href="#2-查看各个内存组件的状态" class="headerlink" title="2. 查看各个内存组件的状态"></a>2. 查看各个内存组件的状态</h3><p>除了全局内存状态外，你还可以使用SHOW ENGINE INNODB STATUS命令来查看InnoDB存储引擎的内存状态。这个命令将返回包含了各种有关InnoDB内存使用情况的信息。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> ENGINE INNODB STATUS;</span><br></pre></td></tr></table></figure><p>这个命令将返回一个包含了InnoDB存储引擎的详细状态信息的文本块，其中包括了各种内存池的使用情况、缓冲池的状态等。</p><h3 id="3-使用Performance-Schema"><a href="#3-使用Performance-Schema" class="headerlink" title="3. 使用Performance Schema"></a>3. 使用Performance Schema</h3><p>MySQL的Performance Schema是一个用于监视和分析MySQL性能的工具。你可以使用Performance Schema来查看MySQL使用的各种内存组件的状态和性能指标。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> performance_schema.memory_summary_global_by_event_name;</span><br></pre></td></tr></table></figure><p>这个查询将返回MySQL使用的各种内存事件的汇总信息，包括内存分配、内存释放等。</p><h3 id="4-使用操作系统工具"><a href="#4-使用操作系统工具" class="headerlink" title="4. 使用操作系统工具"></a>4. 使用操作系统工具</h3><p>除了MySQL自带的工具外，你还可以使用操作系统提供的工具来监视MySQL使用的内存。例如，你可以使用Linux的top命令或者Windows的任务管理器来查看MySQL进程的内存使用情况。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top <span class="operator">-</span>p <span class="operator">&lt;</span>mysql_process_id<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>这个命令将实时显示指定MySQL进程的内存使用情况，包括物理内存和虚拟内存的使用情况。</p><h3 id="5-使用第三方监控工具"><a href="#5-使用第三方监控工具" class="headerlink" title="5. 使用第三方监控工具"></a>5. 使用第三方监控工具</h3><p>此外，还有许多第三方监控工具可以帮助你监视和分析MySQL的内存使用情况。例如，Percona Toolkit提供了一系列用于监控和调优MySQL的工具，其中包括了用于查看内存使用情况的工具。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt<span class="operator">-</span>mysql<span class="operator">-</span>summary</span><br></pre></td></tr></table></figure><p>这个命令将生成一个MySQL实例的摘要报告，其中包括了内存使用情况的详细信息，帮助你更好地理解MySQL的内存使用情况。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>通过本文的介绍，我们了解了如何查看MySQL使用的内存，包括了使用内置命令、Performance Schema、操作系统工具和第三方监控工具等多种方法。通过监视和分析MySQL的内存使用情况，我们可以及时发现并解决内存相关的性能问题，从而提高MySQL的性能和稳定性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：MySQL是一种流行的关系型数据库管理系统，有效管理其内存对于系统的性能和稳定性至关重要。本文将介绍如何查看MySQL使用的内存，包括常见的内存组件和工具，以及如何通过监控和调优来优化MySQL的内存使用。&lt;/p&gt;</summary>
    
    
    
    <category term="MySql" scheme="http://example.com/categories/MySql/"/>
    
    <category term="python" scheme="http://example.com/categories/MySql/python/"/>
    
    
    <category term="MySql" scheme="http://example.com/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 字符字段长度设置详解：语法、注意事项和示例</title>
    <link href="http://example.com/2024/05/18/MySQL-%E5%AD%97%E7%AC%A6%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E8%AE%BE%E7%BD%AE%E8%AF%A6%E8%A7%A3%EF%BC%9A%E8%AF%AD%E6%B3%95%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%A4%BA%E4%BE%8B/"/>
    <id>http://example.com/2024/05/18/MySQL-%E5%AD%97%E7%AC%A6%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E8%AE%BE%E7%BD%AE%E8%AF%A6%E8%A7%A3%EF%BC%9A%E8%AF%AD%E6%B3%95%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%A4%BA%E4%BE%8B/</id>
    <published>2024-05-18T07:21:14.000Z</published>
    <updated>2024-05-18T07:27:06.290Z</updated>
    
    <content type="html"><![CDATA[<p>本文将详细介绍在 MySQL 数据库中如何设置字符字段的长度。将介绍字符字段的数据类型、长度限制、语法示例，并提供具体的示例，以正确设置和管理字符字段的长度。</p><span id="more"></span><h3 id="1-MySQL-字符字段长度概述"><a href="#1-MySQL-字符字段长度概述" class="headerlink" title="1. MySQL 字符字段长度概述"></a>1. MySQL 字符字段长度概述</h3><p>在 MySQL 中，字符字段是用于存储文本型数据的列。字符字段的长度指定了该列可以存储的最大字符数。正确设置字符字段的长度对于数据完整性和性能至关重要。</p><h3 id="2-字符字段数据类型和长度限制"><a href="#2-字符字段数据类型和长度限制" class="headerlink" title="2. 字符字段数据类型和长度限制"></a>2. 字符字段数据类型和长度限制</h3><p>MySQL 提供了多种字符字段数据类型，例如 <code>CHAR</code>、<code>VARCHAR</code>、<code>TEXT</code> 等。这些数据类型具有不同的长度限制和适用场景。</p><ul><li><code>CHAR</code>：固定长度的字符列，最大长度为 255 个字符。</li><li><code>VARCHAR</code>：可变长度的字符列，最大长度为 65,535 个字符。</li><li><code>TEXT</code>：用于存储较长的文本数据，最大长度为 65,535 个字符。</li></ul><h3 id="3-字符字段长度设置语法"><a href="#3-字符字段长度设置语法" class="headerlink" title="3. 字符字段长度设置语法"></a>3. 字符字段长度设置语法</h3><p>设置字符字段的长度需要在创建表或修改表结构时进行。下面是设置字符字段长度的语法示例：</p><ul><li>创建表时设置字符字段长度：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (</span><br><span class="line">    字段名 数据类型(长度)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li>修改表结构时设置字符字段长度：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名</span><br><span class="line">MODIFY 字段名 数据类型(长度);</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-字符字段长度设置示例"><a href="#4-字符字段长度设置示例" class="headerlink" title="4. 字符字段长度设置示例"></a>4. 字符字段长度设置示例</h3><p>接下来，我们将提供不少于5个示例，展示如何设置字符字段的长度。以下示例假设我们正在创建一个存储用户信息的表。</p><ul><li><p>示例 1：使用 <code>CHAR</code> 类型设置固定长度字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span>,</span><br><span class="line">    username <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">    email <span class="type">CHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>示例 2：使用 <code>VARCHAR</code> 类型设置可变长度字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span>,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>示例 3：使用 <code>TEXT</code> 类型存储较长的文本数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span>,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    bio TEXT</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>示例 4：修改表结构时设置字符字段长度：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users</span><br><span class="line">MODIFY username <span class="type">VARCHAR</span>(<span class="number">30</span>);</span><br></pre></td></tr></table></figure></li><li><p>示例 5：使用 <code>VARCHAR</code> 类型存储 URL 地址：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> articles (</span><br><span class="line">    id <span class="type">INT</span>,</span><br><span class="line">    title <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    url <span class="type">VARCHAR</span>(<span class="number">200</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-注意事项和最佳实践"><a href="#5-注意事项和最佳实践" class="headerlink" title="5. 注意事项和最佳实践"></a>5. 注意事项和最佳实践</h3><ul><li>选择适当的字符字段数据类型和长度，避免过度分配存储空间。</li><li>考虑数据的实际需求和预估的最大长度，设置足够的字段长度。</li><li>考虑性能和存储空间的平衡，避免不必要的过长字段。</li><li>对于较长的文本数据，使用 TEXT 类型而不是过长的 VARCHAR 类型。</li><li>注意字符集和排序规则的设置，以确保正确存储和比较字符数据。</li></ul><h3 id="6-如何选择适当的字符字段数据类型和长度的建议"><a href="#6-如何选择适当的字符字段数据类型和长度的建议" class="headerlink" title="6. 如何选择适当的字符字段数据类型和长度的建议"></a>6. 如何选择适当的字符字段数据类型和长度的建议</h3><ol><li>了解数据的特性：首先要了解您要存储的数据的特性和需求。考虑数据的类型、长度范围、频繁性和变化性等因素。</li><li>选择合适的数据类型：MySQL 提供了多种字符字段数据类型，如 CHAR、VARCHAR、TEXT 等。根据数据的长度和变化性选择合适的数据类型。<ul><li>CHAR：适合存储固定长度的字符串，例如国家代码或固定长度的标识符。长度范围为 0-255。</li><li>VARCHAR：适合存储可变长度的字符串，长度范围为 0-65,535。根据数据的最大长度进行设置。</li><li>TEXT：适合存储较长的文本数据，长度范围为 0-65,535。用于存储大块文本，如文章内容、备注等。</li></ul></li><li>避免过度分配存储空间：不要为字符字段分配过长的长度，以避免浪费存储空间。根据数据的实际需求和预估的最大长度进行合理设置。</li><li>考虑性能和存储空间的平衡：过长的字符字段会占用更多的存储空间，可能会影响查询性能。根据实际需求和预估的最大长度，在性能和存储空间之间取得平衡。</li><li>使用 TEXT 类型存储较长的文本数据：如果您需要存储超过 65,535 个字符的文本数据，应使用 TEXT 类型，而不是过长的 VARCHAR 类型。</li><li>考虑字符集和排序规则：根据数据的语言和排序要求，选择合适的字符集和排序规则。不同字符集和排序规则可能对字段长度产生影响，特别是对于多字节字符集。</li><li>测试和验证：在设计数据库结构之前，进行测试和验证以确保所选的字段数据类型和长度满足实际需求。考虑不同数据集的情况，并确保字段长度足够容纳所有可能的值。</li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>本文介绍了在 MySQL 数据库中设置字符字段长度的方法。我们讨论了字符字段的数据类型、长度限制和设置语法。通过正确设置字符字段的长度，您可以确保数据的完整性、性能和存储效率。请根据实际需求和最佳实践进行适当的设置和管理。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将详细介绍在 MySQL 数据库中如何设置字符字段的长度。将介绍字符字段的数据类型、长度限制、语法示例，并提供具体的示例，以正确设置和管理字符字段的长度。&lt;/p&gt;</summary>
    
    
    
    <category term="MySql" scheme="http://example.com/categories/MySql/"/>
    
    <category term="python" scheme="http://example.com/categories/MySql/python/"/>
    
    
    <category term="MySql" scheme="http://example.com/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>深入理解MySQL：查询表的历史操作记录</title>
    <link href="http://example.com/2024/05/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MySQL%EF%BC%9A%E6%9F%A5%E8%AF%A2%E8%A1%A8%E7%9A%84%E5%8E%86%E5%8F%B2%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2024/05/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MySQL%EF%BC%9A%E6%9F%A5%E8%AF%A2%E8%A1%A8%E7%9A%84%E5%8E%86%E5%8F%B2%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/</id>
    <published>2024-05-18T07:18:37.000Z</published>
    <updated>2024-05-18T07:20:46.107Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：在数据库管理中，了解如何查询表的历史操作记录对于追踪数据变更、审计数据以及恢复误操作至关重要。本文将深入探讨MySQL中查询表的历史操作记录的方法，并提供多个实例以帮助读者更好地理解和应用这一技术。</p><span id="more"></span><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在数据库管理中，了解数据库表的历史操作记录是非常重要的。通过查询历史操作记录，我们可以追踪数据的变更情况、审计数据的操作，甚至在数据误操作时进行恢复。MySQL作为一种流行的关系型数据库管理系统，提供了多种方法来查询表的历史操作记录。本文将深入介绍这些方法，并通过实例演示如何使用它们。</p><h3 id="1-使用触发器记录历史操作"><a href="#1-使用触发器记录历史操作" class="headerlink" title="1. 使用触发器记录历史操作"></a>1. 使用触发器记录历史操作</h3><p>MySQL中的触发器是一种特殊的存储过程，可以在表上执行INSERT、UPDATE和DELETE操作时触发。通过使用触发器，我们可以在表的操作发生时记录操作历史。</p><p>示例：</p><p>假设我们有一个名为customers的表，我们可以创建一个触发器，在每次对该表执行INSERT、UPDATE或DELETE操作时，将操作记录插入到历史记录表customers_history中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> customers_history_trigger</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> customers</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers_history (customer_id, action, action_time)</span><br><span class="line"><span class="keyword">VALUES</span> (NEW.id, <span class="string">&#x27;INSERT&#x27;</span>, NOW());</span><br></pre></td></tr></table></figure><h3 id="2-使用历史表记录变更"><a href="#2-使用历史表记录变更" class="headerlink" title="2. 使用历史表记录变更"></a>2. 使用历史表记录变更</h3><p>除了触发器外，还可以通过创建历史表来记录数据的变更情况。每次对原始表执行操作时，将变更记录插入到历史表中。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers_history (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    customer_id <span class="type">INT</span>,</span><br><span class="line">    action ENUM(<span class="string">&#x27;INSERT&#x27;</span>, <span class="string">&#x27;UPDATE&#x27;</span>, <span class="string">&#x27;DELETE&#x27;</span>),</span><br><span class="line">    action_time <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在每次操作时，将变更记录插入到历史表中</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers_history (customer_id, action)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;UPDATE&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="3-使用二进制日志文件记录操作"><a href="#3-使用二进制日志文件记录操作" class="headerlink" title="3. 使用二进制日志文件记录操作"></a>3. 使用二进制日志文件记录操作</h3><p>MySQL的二进制日志文件（Binary Log）记录了数据库的所有操作，包括数据表的增删改操作。通过分析二进制日志文件，我们可以获取到数据库的历史操作记录。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 启用二进制日志</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> log_bin <span class="operator">=</span> <span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure><p>然后，通过分析二进制日志文件来获取数据库的历史操作记录。</p><h3 id="4-使用时间机器表查询历史数据"><a href="#4-使用时间机器表查询历史数据" class="headerlink" title="4. 使用时间机器表查询历史数据"></a>4. 使用时间机器表查询历史数据</h3><p>MySQL 5.7版本引入了一项新功能：时间机器表（Temporal Tables）。时间机器表可以跟踪数据在不同时间点的变化，并提供了一种简单而强大的方式来查询历史数据。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建时间机器表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers_temporal (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    valid_from <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    valid_to <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;9999-12-31 23:59:59&#x27;</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">SYSTEM</span> <span class="keyword">VERSIONING</span>;</span><br></pre></td></tr></table></figure><p>然后，通过查询时间机器表来获取历史数据。</p><h3 id="5-使用第三方工具或扩展"><a href="#5-使用第三方工具或扩展" class="headerlink" title="5. 使用第三方工具或扩展"></a>5. 使用第三方工具或扩展</h3><p>除了以上方法外，还可以使用一些第三方工具或扩展来查询表的历史操作记录。例如，可以使用MySQL的审计插件或者一些数据库监控工具来实现这一目的。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>通过本文的介绍，我们深入了解了MySQL中查询表的历史操作记录的方法，并通过多个实例演示了如何使用这些方法。无论是使用触发器、历史表、二进制日志文件、时间机器表还是第三方工具，都能够帮助我们追踪数据的变更情况、审计数据的操作，并在数据误操作时进行恢复。在实际应用中，根据具体情况选择合适的方法，将会大大提高数据库管理的效率和可靠性。</p><p>本文详细介绍了MySQL中查询表的历史操作记录的方法，并提供了多个实例，希望对你有所帮助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：在数据库管理中，了解如何查询表的历史操作记录对于追踪数据变更、审计数据以及恢复误操作至关重要。本文将深入探讨MySQL中查询表的历史操作记录的方法，并提供多个实例以帮助读者更好地理解和应用这一技术。&lt;/p&gt;</summary>
    
    
    
    <category term="MySql" scheme="http://example.com/categories/MySql/"/>
    
    <category term="python" scheme="http://example.com/categories/MySql/python/"/>
    
    
    <category term="MySql" scheme="http://example.com/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 查询结果求和详解</title>
    <link href="http://example.com/2024/05/18/MySQL-%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E6%B1%82%E5%92%8C%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2024/05/18/MySQL-%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E6%B1%82%E5%92%8C%E8%AF%A6%E8%A7%A3/</id>
    <published>2024-05-18T07:15:50.000Z</published>
    <updated>2024-05-18T07:17:50.063Z</updated>
    
    <content type="html"><![CDATA[<p>在数据库中，求和查询是一种常见的操作，特别是在处理大量数据时。MySQL 提供了多种方法来执行求和操作，本文将详细介绍这些方法，并通过示例加以说明。</p><span id="more"></span><h3 id="1-使用-SUM-函数"><a href="#1-使用-SUM-函数" class="headerlink" title="1. 使用 SUM() 函数"></a>1. 使用 SUM() 函数</h3><p>SUM() 函数是 MySQL 中用于求和的基本函数之一。它可以对指定列中的数值进行求和。</p><p>示例 1： 假设我们有一个名为 sales 的表，其中包含了销售数据，我们想要计算所有销售额的总和。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_sales <span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure><p>这将返回一个名为 total_sales 的列，其中包含了 sales 表中所有销售额的总和。</p><h3 id="2-使用-GROUP-BY-子句"><a href="#2-使用-GROUP-BY-子句" class="headerlink" title="2. 使用 GROUP BY 子句"></a>2. 使用 GROUP BY 子句</h3><p>如果我们想要按照某一列的值进行分组求和，就需要使用 GROUP BY 子句。</p><p>示例 2： 假设我们想要计算每个月的销售总额。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(<span class="type">date</span>), <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> monthly_sales </span><br><span class="line"><span class="keyword">FROM</span> sales </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">MONTH</span>(<span class="type">date</span>);</span><br></pre></td></tr></table></figure><p>这将返回每个月份的销售总额。</p><h3 id="3-结合-WHERE-子句"><a href="#3-结合-WHERE-子句" class="headerlink" title="3. 结合 WHERE 子句"></a>3. 结合 WHERE 子句</h3><p>结合 WHERE 子句可以对数据进行筛选，然后再进行求和操作。</p><p>示例 3： 假设我们只想计算某个销售代表的销售额。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_sales <span class="keyword">FROM</span> sales <span class="keyword">WHERE</span> salesman_id <span class="operator">=</span> <span class="number">101</span>;</span><br></pre></td></tr></table></figure><p>这将返回销售代表 ID 为 101 的销售额总和。</p><h3 id="4-使用-WITH-ROLLUP-实现分组小计"><a href="#4-使用-WITH-ROLLUP-实现分组小计" class="headerlink" title="4. 使用 WITH ROLLUP 实现分组小计"></a>4. 使用 WITH ROLLUP 实现分组小计</h3><p>WITH ROLLUP 可以在 GROUP BY 查询的结果中添加小计行。</p><p>示例 4： 假设我们想要计算每个月份的销售总额，并添加一个总计行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    IFNULL(<span class="keyword">MONTH</span>(<span class="type">date</span>), <span class="string">&#x27;Total&#x27;</span>) <span class="keyword">AS</span> <span class="keyword">Month</span>, </span><br><span class="line">    <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> monthly_sales </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    sales </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">    <span class="keyword">MONTH</span>(<span class="type">date</span>) <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br></pre></td></tr></table></figure><p>这将在结果中添加一个总计行，显示所有月份的销售总额。</p><h3 id="5-使用-JOIN-进行复杂求和"><a href="#5-使用-JOIN-进行复杂求和" class="headerlink" title="5. 使用 JOIN 进行复杂求和"></a>5. 使用 JOIN 进行复杂求和</h3><p>有时，我们需要在多个表之间进行联合查询，并对结果进行求和。</p><p>示例 5： 假设我们有一个 orders 表，包含了订单信息，我们想要计算每个客户的订单总额。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    customers.name, </span><br><span class="line">    <span class="built_in">SUM</span>(orders.amount) <span class="keyword">AS</span> total_order_amount </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    customers </span><br><span class="line"><span class="keyword">JOIN</span> </span><br><span class="line">    orders <span class="keyword">ON</span> customers.id <span class="operator">=</span> orders.customer_id </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">    customers.name;</span><br></pre></td></tr></table></figure><p>这将返回每个客户的订单总额。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>MySQL 提供了丰富的功能来执行求和查询，包括基本的 SUM() 函数、GROUP BY 子句、WITH ROLLUP、JOIN 等。通过合理地组合和运用这些功能，我们可以高效地处理数据并获得所需的汇总信息。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在数据库中，求和查询是一种常见的操作，特别是在处理大量数据时。MySQL 提供了多种方法来执行求和操作，本文将详细介绍这些方法，并通过示例加以说明。&lt;/p&gt;</summary>
    
    
    
    <category term="MySql" scheme="http://example.com/categories/MySql/"/>
    
    <category term="python" scheme="http://example.com/categories/MySql/python/"/>
    
    
    <category term="MySql" scheme="http://example.com/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL技术深度解析：每次最大插入条数探秘</title>
    <link href="http://example.com/2024/05/18/MySQL%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E6%AF%8F%E6%AC%A1%E6%9C%80%E5%A4%A7%E6%8F%92%E5%85%A5%E6%9D%A1%E6%95%B0%E6%8E%A2%E7%A7%98/"/>
    <id>http://example.com/2024/05/18/MySQL%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E6%AF%8F%E6%AC%A1%E6%9C%80%E5%A4%A7%E6%8F%92%E5%85%A5%E6%9D%A1%E6%95%B0%E6%8E%A2%E7%A7%98/</id>
    <published>2024-05-18T07:11:38.000Z</published>
    <updated>2024-05-18T07:14:07.819Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：在MySQL数据库管理中，了解每次最大插入条数是至关重要的。本文将深入探讨MySQL中每次最大插入条数的相关问题，包括影响因素、如何设置以及实际应用中的典型场景，并提供详细的示例。</p><span id="more"></span><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>MySQL作为一款流行的关系型数据库管理系统，其性能和可靠性备受推崇。在实际应用中，我们经常需要将大量数据插入到MySQL数据库中。然而，MySQL对于每次插入的最大条数有一定的限制，了解这一限制对于优化数据库性能和提高数据导入效率至关重要。</p><h4 id="1-影响因素"><a href="#1-影响因素" class="headerlink" title="1. 影响因素"></a>1. 影响因素</h4><p>MySQL中每次最大插入条数受多种因素影响，包括但不限于：</p><p>服务器配置：服务器的硬件配置（如内存、CPU）和软件配置（如MySQL参数设置）会直接影响每次插入的最大条数。<br>表结构：表的结构（如字段数量、字段类型）以及是否存在索引等因素都会对每次插入的最大条数产生影响。<br>MySQL版本：不同版本的MySQL可能会有不同的限制，因此在使用时需要特别留意。</p><h4 id="2-如何查看当前限制"><a href="#2-如何查看当前限制" class="headerlink" title="2. 如何查看当前限制"></a>2. 如何查看当前限制</h4><p>要查看当前MySQL中每次最大插入条数的限制，可以通过以下方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;max_allowed_packet&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这将显示当前MySQL实例中每次插入的最大字节数限制。</p><h4 id="3-如何设置最大插入条数"><a href="#3-如何设置最大插入条数" class="headerlink" title="3. 如何设置最大插入条数"></a>3. 如何设置最大插入条数</h4><p>在MySQL中，可以通过修改max_allowed_packet参数来设置每次最大插入条数的限制。该参数表示允许的最大数据包大小，单位为字节。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> max_allowed_packet <span class="operator">=</span> size;</span><br></pre></td></tr></table></figure><p>其中，size为所需设置的最大数据包大小，单位为字节。请注意，修改此参数可能需要相应的权限。</p><h4 id="4-典型场景举例"><a href="#4-典型场景举例" class="headerlink" title="4. 典型场景举例"></a>4. 典型场景举例</h4><h5 id="4-1-大批量数据导入"><a href="#4-1-大批量数据导入" class="headerlink" title="4.1 大批量数据导入"></a>4.1 大批量数据导入</h5><p>在数据迁移或者初始化过程中，经常需要将大量数据导入到MySQL数据库中。限制每次插入的最大条数可能会影响数据导入的效率。</p><p>示例：</p><p>假设我们有一个名为users的表，现在需要从另一个数据源导入10000条用户数据到该表中。如果每次最大插入条数为1000条，那么我们需要分成多次插入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (name, email) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;user1&#x27;</span>, <span class="string">&#x27;user1@example.com&#x27;</span>),</span><br><span class="line">...</span><br><span class="line">(<span class="string">&#x27;user1000&#x27;</span>, <span class="string">&#x27;user1000@example.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (name, email) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;user1001&#x27;</span>, <span class="string">&#x27;user1001@example.com&#x27;</span>),</span><br><span class="line">...</span><br><span class="line">(<span class="string">&#x27;user2000&#x27;</span>, <span class="string">&#x27;user2000@example.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="4-2-大事务处理"><a href="#4-2-大事务处理" class="headerlink" title="4.2 大事务处理"></a>4.2 大事务处理</h5><p>在某些情况下，我们需要执行大事务，其中可能包含大量的INSERT操作。每次插入的最大条数限制会影响事务的执行效率和性能。</p><p>示例：</p><p>假设我们需要在一个事务中向多个相关表中插入大量数据，如果每次最大插入条数较小，可能需要将事务分解为多个较小的事务来执行。</p><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h4><p>MySQL中每次最大插入条数是数据库管理中一个重要的概念，对于优化数据库性能和提高数据导入效率至关重要。本文从影响因素、设置方法以及典型场景等方面对这一概念进行了深入探讨，并提供了详细的示例以帮助读者更好地理解和应用。</p><p>在实际应用中，需要根据具体情况调整MySQL参数，并结合优化策略来达到最佳效果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：在MySQL数据库管理中，了解每次最大插入条数是至关重要的。本文将深入探讨MySQL中每次最大插入条数的相关问题，包括影响因素、如何设置以及实际应用中的典型场景，并提供详细的示例。&lt;/p&gt;</summary>
    
    
    
    <category term="MySql" scheme="http://example.com/categories/MySql/"/>
    
    <category term="python" scheme="http://example.com/categories/MySql/python/"/>
    
    
    <category term="MySql" scheme="http://example.com/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL技术指南：如何更改数据字段的前几位数字</title>
    <link href="http://example.com/2024/05/18/MySQL%E6%8A%80%E6%9C%AF%E6%8C%87%E5%8D%97%EF%BC%9A%E5%A6%82%E4%BD%95%E6%9B%B4%E6%94%B9%E6%95%B0%E6%8D%AE%E5%AD%97%E6%AE%B5%E7%9A%84%E5%89%8D%E5%87%A0%E4%BD%8D%E6%95%B0%E5%AD%97/"/>
    <id>http://example.com/2024/05/18/MySQL%E6%8A%80%E6%9C%AF%E6%8C%87%E5%8D%97%EF%BC%9A%E5%A6%82%E4%BD%95%E6%9B%B4%E6%94%B9%E6%95%B0%E6%8D%AE%E5%AD%97%E6%AE%B5%E7%9A%84%E5%89%8D%E5%87%A0%E4%BD%8D%E6%95%B0%E5%AD%97/</id>
    <published>2024-05-18T07:03:59.000Z</published>
    <updated>2024-05-18T07:12:19.828Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：MySQL是一款强大的关系型数据库管理系统，本文将介绍如何使用MySQL来更改数据字段中的前几位数字。通过详细的步骤和实际案例，读者将能够轻松地掌握这一技术。</p><span id="more"></span><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>在数据库管理中，有时候我们需要对数据进行修改以满足特定需求，其中之一就是更改数据字段的前几位数字。这可能涉及到诸如更新电话号码的区号、修改身份证号码的前几位等操作。MySQL提供了一系列功能强大的函数和语法，使得这些操作变得简单而高效。</p><h4 id="使用SUBSTRING函数"><a href="#使用SUBSTRING函数" class="headerlink" title="使用SUBSTRING函数"></a>使用SUBSTRING函数</h4><p>SUBSTRING函数允许我们截取字段中的指定部分。通过结合其他函数，我们可以实现对前几位数字的修改。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column_name <span class="operator">=</span> CONCAT(<span class="string">&#x27;new_prefix&#x27;</span>, <span class="built_in">SUBSTRING</span>(column_name, length_of_prefix <span class="operator">+</span> <span class="number">1</span>))</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><p>示例：</p><p>假设我们有一个电话号码字段phone_number，现在需要将其前三位数字由”123”改为”456”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> customers</span><br><span class="line"><span class="keyword">SET</span> phone_number <span class="operator">=</span> CONCAT(<span class="string">&#x27;456&#x27;</span>, <span class="built_in">SUBSTRING</span>(phone_number, <span class="number">4</span>))</span><br><span class="line"><span class="keyword">WHERE</span> phone_number <span class="keyword">LIKE</span> <span class="string">&#x27;123%&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="使用REPLACE函数"><a href="#使用REPLACE函数" class="headerlink" title="使用REPLACE函数"></a>使用REPLACE函数</h4><p>REPLACE函数可以替换字段中的指定字符串，结合SUBSTRING函数，我们可以实现对前几位数字的修改。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column_name <span class="operator">=</span> CONCAT(<span class="string">&#x27;new_prefix&#x27;</span>, <span class="built_in">SUBSTRING</span>(column_name, length_of_prefix <span class="operator">+</span> <span class="number">1</span>))</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><p>示例：</p><p>假设我们有一个身份证号码字段id_number，现在需要将其前六位数字由”123456”改为”654321”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span> id_number <span class="operator">=</span> CONCAT(<span class="string">&#x27;654321&#x27;</span>, <span class="built_in">SUBSTRING</span>(id_number, <span class="number">7</span>))</span><br><span class="line"><span class="keyword">WHERE</span> id_number <span class="keyword">LIKE</span> <span class="string">&#x27;123456%&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="使用LEFT和CONCAT函数"><a href="#使用LEFT和CONCAT函数" class="headerlink" title="使用LEFT和CONCAT函数"></a>使用LEFT和CONCAT函数</h4><p>LEFT函数用于截取字段的左侧指定长度的字符，结合CONCAT函数，我们可以实现对前几位数字的修改。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column_name <span class="operator">=</span> CONCAT(<span class="string">&#x27;new_prefix&#x27;</span>, <span class="built_in">SUBSTRING</span>(column_name, length_of_prefix <span class="operator">+</span> <span class="number">1</span>))</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><p>示例：</p><p>假设我们有一个邮政编码字段postal_code，现在需要将其前两位数字由”12”改为”98”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> addresses</span><br><span class="line"><span class="keyword">SET</span> postal_code <span class="operator">=</span> CONCAT(<span class="string">&#x27;98&#x27;</span>, <span class="built_in">SUBSTRING</span>(postal_code, <span class="number">3</span>))</span><br><span class="line"><span class="keyword">WHERE</span> LENGTH(postal_code) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h4 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h4><p>MySQL支持正则表达式，我们可以使用REGEXP_REPLACE函数实现对前几位数字的修改。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column_name <span class="operator">=</span> REGEXP_REPLACE(column_name, <span class="string">&#x27;pattern&#x27;</span>, <span class="string">&#x27;replacement&#x27;</span>)</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><p>示例：</p><p>假设我们有一个订单号字段order_id，现在需要将其前四位数字由”1234”改为”5678”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> orders</span><br><span class="line"><span class="keyword">SET</span> order_id <span class="operator">=</span> REGEXP_REPLACE(order_id, <span class="string">&#x27;^1234&#x27;</span>, <span class="string">&#x27;5678&#x27;</span>)</span><br><span class="line"><span class="keyword">WHERE</span> order_id REGEXP <span class="string">&#x27;^1234&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="使用CASE语句"><a href="#使用CASE语句" class="headerlink" title="使用CASE语句"></a>使用CASE语句</h4><p>在某些复杂情况下，我们可以使用CASE语句根据条件来修改字段的前几位数字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column_name <span class="operator">=</span> </span><br><span class="line">  <span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> condition_1 <span class="keyword">THEN</span> new_value_1</span><br><span class="line">    <span class="keyword">WHEN</span> condition_2 <span class="keyword">THEN</span> new_value_2</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">ELSE</span> column_name</span><br><span class="line">  <span class="keyword">END</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><p>示例：</p><p>假设我们有一个产品编码字段product_code，现在需要根据不同的条件修改其前三位数字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> products</span><br><span class="line"><span class="keyword">SET</span> product_code <span class="operator">=</span> </span><br><span class="line">  <span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> category <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span> <span class="keyword">THEN</span> CONCAT(<span class="string">&#x27;111&#x27;</span>, <span class="built_in">SUBSTRING</span>(product_code, <span class="number">4</span>))</span><br><span class="line">    <span class="keyword">WHEN</span> category <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span> <span class="keyword">THEN</span> CONCAT(<span class="string">&#x27;222&#x27;</span>, <span class="built_in">SUBSTRING</span>(product_code, <span class="number">4</span>))</span><br><span class="line">    <span class="keyword">ELSE</span> product_code</span><br><span class="line">  <span class="keyword">END</span></span><br><span class="line"><span class="keyword">WHERE</span> LENGTH(product_code) <span class="operator">&gt;=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h4 id="使用数字运算"><a href="#使用数字运算" class="headerlink" title="使用数字运算"></a>使用数字运算</h4><p>在某些情况下，我们可以通过数字运算来修改字段的前几位数字，特别是当数字具有规律性时。</p><p>示例：</p><p>假设我们有一个订单号字段order_number，现在需要将其前两位数字加上固定值10。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> orders</span><br><span class="line"><span class="keyword">SET</span> order_number <span class="operator">=</span> order_number <span class="operator">+</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">WHERE</span> order_number <span class="operator">&gt;=</span> <span class="number">1000</span> <span class="keyword">AND</span> order_number <span class="operator">&lt;</span> <span class="number">2000</span>;</span><br></pre></td></tr></table></figure><h4 id="使用自定义函数"><a href="#使用自定义函数" class="headerlink" title="使用自定义函数"></a>使用自定义函数</h4><p>如果需要更复杂的操作，可以使用自定义函数来处理数据。</p><p>示例：</p><p>假设我们有一个学生成绩字段grade，现在需要根据特定规则对前两位数字进行调整，比如加上学校代码。</p><p>首先，我们创建一个自定义函数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> modify_grade(original_grade <span class="type">VARCHAR</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> school_code <span class="type">VARCHAR</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">SET</span> school_code <span class="operator">=</span> <span class="string">&#x27;AB&#x27;</span>; <span class="comment">-- 假设学校代码为&#x27;AB&#x27;</span></span><br><span class="line">    <span class="keyword">RETURN</span> CONCAT(school_code, <span class="built_in">SUBSTRING</span>(original_grade, <span class="number">3</span>));</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>然后，我们可以使用这个函数来更新数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> students</span><br><span class="line"><span class="keyword">SET</span> grade <span class="operator">=</span> modify_grade(grade)</span><br><span class="line"><span class="keyword">WHERE</span> ...; <span class="comment">-- 添加适当的条件</span></span><br></pre></td></tr></table></figure><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>通过本文的介绍，我们学习了如何使用MySQL来更改数据字段中的前几位数字。无论是使用SUBSTRING函数、REPLACE函数、LEFT函数，还是正则表达式或者CASE语句，都能够轻松地实现这一目标。在实际应用中，根据具体需求选择合适的方法，将会大大提高工作效率。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：MySQL是一款强大的关系型数据库管理系统，本文将介绍如何使用MySQL来更改数据字段中的前几位数字。通过详细的步骤和实际案例，读者将能够轻松地掌握这一技术。&lt;/p&gt;</summary>
    
    
    
    <category term="MySql" scheme="http://example.com/categories/MySql/"/>
    
    <category term="python" scheme="http://example.com/categories/MySql/python/"/>
    
    
    <category term="MySql" scheme="http://example.com/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>Python 时间处理与时区转换：深入探究 datetime、time 模块与 pytz 库的功能与应用</title>
    <link href="http://example.com/2023/12/11/Python-%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E4%B8%8E%E6%97%B6%E5%8C%BA%E8%BD%AC%E6%8D%A2%EF%BC%9A%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6-datetime%E3%80%81time-%E6%A8%A1%E5%9D%97%E4%B8%8E-pytz-%E5%BA%93%E7%9A%84%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>http://example.com/2023/12/11/Python-%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E4%B8%8E%E6%97%B6%E5%8C%BA%E8%BD%AC%E6%8D%A2%EF%BC%9A%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6-datetime%E3%80%81time-%E6%A8%A1%E5%9D%97%E4%B8%8E-pytz-%E5%BA%93%E7%9A%84%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2023-12-11T14:01:43.000Z</published>
    <updated>2023-12-11T14:12:04.219Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中的 datetime 和 time 模块为处理时间和日期提供了强大的功能。这些模块不仅支持时间和日期的操作，还能进行时间戳的转换、时区操作等。在本文中，我们将深入介绍这些模块的用法和实际示例。</p><span id="more"></span><h2 id="1-datetime-模块：处理日期和时间"><a href="#1-datetime-模块：处理日期和时间" class="headerlink" title="1. datetime 模块：处理日期和时间"></a>1. datetime 模块：处理日期和时间</h2><p>datetime 模块是 Python 标准库中用于处理日期和时间的模块。它提供了多个类和函数，用于创建、操作和格式化日期时间对象。datetime 模块的核心类是 datetime 类，它能够表示日期和时间，并提供了丰富的方法来进行计算和操作。</p><p>以下是 datetime 模块中常用的一些类和方法：</p><h3 id="1-1-datetime-类"><a href="#1-1-datetime-类" class="headerlink" title="1.1 datetime 类"></a>1.1 datetime 类</h3><p>datetime 类用于表示具体的日期和时间。它包含了年、月、日、时、分、秒等信息，并支持进行日期时间的算术运算和比较。</p><p><strong>创建日期时间对象：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">current_datetime = datetime.now()  <span class="comment"># 获取当前日期时间</span></span><br><span class="line">specific_datetime = datetime(<span class="number">2023</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">0</span>)  <span class="comment"># 创建特定日期时间对象</span></span><br></pre></td></tr></table></figure><p><strong>日期时间格式化：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">formatted_date = current_datetime.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)  <span class="comment"># 格式化日期时间</span></span><br></pre></td></tr></table></figure><p><strong>日期时间运算：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"></span><br><span class="line">new_datetime = current_datetime + timedelta(days=<span class="number">5</span>, hours=<span class="number">3</span>)  <span class="comment"># 进行日期时间的加减运算</span></span><br></pre></td></tr></table></figure><h3 id="1-2-timedelta-类"><a href="#1-2-timedelta-类" class="headerlink" title="1.2 timedelta 类"></a>1.2 timedelta 类</h3><p>timedelta 类表示时间间隔，可用于在日期时间上进行加减操作。</p><p><strong>创建时间间隔：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"></span><br><span class="line">time_delta = timedelta(days=<span class="number">5</span>, hours=<span class="number">3</span>, minutes=<span class="number">20</span>)  <span class="comment"># 创建时间间隔对象</span></span><br></pre></td></tr></table></figure><p><strong>与日期时间进行运算：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_datetime = current_datetime + time_delta  <span class="comment"># 日期时间与时间间隔相加</span></span><br></pre></td></tr></table></figure><h3 id="1-3-其他方法和函数"><a href="#1-3-其他方法和函数" class="headerlink" title="1.3 其他方法和函数"></a>1.3 其他方法和函数</h3><ul><li>datetime.strptime()：将字符串解析为日期时间对象。</li><li>datetime.combine()：将日期和时间组合成一个新的日期时间对象。</li><li>datetime.now()：获取当前日期时间。</li><li>datetime.date() 和 datetime.time()：分别获取日期和时间部分。</li></ul><h3 id="示例-1：获取当前日期时间"><a href="#示例-1：获取当前日期时间" class="headerlink" title="示例 1：获取当前日期时间"></a>示例 1：获取当前日期时间</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">now = datetime.now()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Current Date and Time:&quot;</span>, now)</span><br></pre></td></tr></table></figure><p><strong>示例 2：格式化日期时间</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">formatted_date = now.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Formatted Date:&quot;</span>, formatted_date)</span><br></pre></td></tr></table></figure><h2 id="2-time-模块：处理时间和时间戳"><a href="#2-time-模块：处理时间和时间戳" class="headerlink" title="2. time 模块：处理时间和时间戳"></a>2. time 模块：处理时间和时间戳</h2><p>time 模块提供了处理时间和时间戳的功能，能够获取当前时间、进行时间戳转换等操作。</p><p>time 模块是 Python 标准库中用于处理时间的模块，它提供了许多与时间相关的功能，包括时间获取、时间戳处理、睡眠等。与 datetime 不同，time 模块主要用于处理时间本身，而不涉及日期的处理。</p><p>以下是 time 模块中常用的一些函数和类：</p><h3 id="2-1-时间获取"><a href="#2-1-时间获取" class="headerlink" title="2.1 时间获取"></a>2.1 时间获取</h3><p><strong>time() 函数：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">current_time = time.time()  <span class="comment"># 获取当前时间的时间戳（从1970年1月1日开始计算的秒数）</span></span><br></pre></td></tr></table></figure><p><strong>ctime() 函数：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">formatted_time = time.ctime()  <span class="comment"># 获取当前时间的可读形式</span></span><br></pre></td></tr></table></figure><h3 id="2-2-时间格式化"><a href="#2-2-时间格式化" class="headerlink" title="2.2 时间格式化"></a>2.2 时间格式化</h3><p><strong>strftime() 函数：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">formatted_time = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime())  <span class="comment"># 将时间转换为指定格式的字符串</span></span><br></pre></td></tr></table></figure><h3 id="2-3-睡眠"><a href="#2-3-睡眠" class="headerlink" title="2.3 睡眠"></a>2.3 睡眠</h3><p><strong>sleep() 函数：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.sleep(<span class="number">5</span>)  <span class="comment"># 暂停程序执行，单位为秒</span></span><br></pre></td></tr></table></figure><h3 id="2-4-时间元组"><a href="#2-4-时间元组" class="headerlink" title="2.4 时间元组"></a>2.4 时间元组</h3><p><strong>struct_time 类型：</strong><br>time.localtime() 和 time.gmtime() 返回的是 struct_time 类型的对象，包含了时间的各个元素（年、月、日、时、分、秒等）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current_local_time = time.localtime()  <span class="comment"># 获取本地时间的时间元组</span></span><br><span class="line">current_utc_time = time.gmtime()  <span class="comment"># 获取UTC时间的时间元组</span></span><br></pre></td></tr></table></figure><h3 id="2-5-其他函数"><a href="#2-5-其他函数" class="headerlink" title="2.5 其他函数"></a>2.5 其他函数</h3><ul><li>time.sleep()：使程序暂停指定的时间（秒）。</li><li>time.monotonic()：返回一个单调递增的时间，用于性能计时。</li><li>time.clock()（Python 3.8 之前）或 time.perf_counter()（Python 3.3+）：返回程序运行时间的高精度值。<br>time 模块提供了许多函数和方法来处理时间，包括获取当前时间、时间格式化、睡眠等操作。这些功能可以满足对时间处理和计时的多种需求，使得 Python 在时间相关的操作上更加灵活和强大。</li></ul><h3 id="示例-3：获取当前时间戳"><a href="#示例-3：获取当前时间戳" class="headerlink" title="示例 3：获取当前时间戳"></a>示例 3：获取当前时间戳</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">timestamp = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Current Timestamp:&quot;</span>, timestamp)</span><br></pre></td></tr></table></figure><h3 id="示例-4：将时间戳转换为日期时间"><a href="#示例-4：将时间戳转换为日期时间" class="headerlink" title="示例 4：将时间戳转换为日期时间"></a>示例 4：将时间戳转换为日期时间</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timestamp = <span class="number">1634156485.123456789</span></span><br><span class="line">converted_time = datetime.fromtimestamp(timestamp)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Converted Time:&quot;</span>, converted_time)</span><br></pre></td></tr></table></figure><h2 id="3-时区操作与切换"><a href="#3-时区操作与切换" class="headerlink" title="3. 时区操作与切换"></a>3. 时区操作与切换</h2><p>时区操作在处理时间时非常重要，特别是在涉及多个时区的情况下。Python 中通过第三方库 pytz 来处理时区信息。pytz 提供了时区相关的功能，允许在不同的时区之间进行转换、操作和表示。</p><h3 id="3-1-时区对象创建"><a href="#3-1-时区对象创建" class="headerlink" title="3.1 时区对象创建"></a>3.1 时区对象创建</h3><p>pytz 可以创建表示不同时区的对象，并将其应用于日期时间对象。</p><p><strong>创建时区对象：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line"></span><br><span class="line">local_tz = pytz.timezone(<span class="string">&#x27;Asia/Shanghai&#x27;</span>)  <span class="comment"># 创建表示上海时区的对象</span></span><br><span class="line">utc_tz = pytz.utc  <span class="comment"># 创建表示 UTC 时区的对象</span></span><br></pre></td></tr></table></figure><h3 id="3-2-时区转换与应用"><a href="#3-2-时区转换与应用" class="headerlink" title="3.2 时区转换与应用"></a>3.2 时区转换与应用</h3><p><strong>将本地时间转换为特定时区时间：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前时间，并将其应用于上海时区</span></span><br><span class="line">local_time = datetime.now()</span><br><span class="line">local_time = local_tz.localize(local_time)</span><br></pre></td></tr></table></figure><p><strong>将时区转换为其他时区：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将上海时区时间转换为 UTC 时间</span></span><br><span class="line">utc_time = local_time.astimezone(pytz.utc)</span><br></pre></td></tr></table></figure><h3 id="3-3-时区信息与操作"><a href="#3-3-时区信息与操作" class="headerlink" title="3.3 时区信息与操作"></a>3.3 时区信息与操作</h3><p><strong>获取时区相关信息：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tz_list = pytz.all_timezones  <span class="comment"># 获取所有时区列表</span></span><br><span class="line">tz_info = local_time.tzinfo  <span class="comment"># 获取日期时间对象的时区信息</span></span><br></pre></td></tr></table></figure><p><strong>执行时区操作：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 UTC 时间转换为纽约时区时间</span></span><br><span class="line">ny_tz = pytz.timezone(<span class="string">&#x27;America/New_York&#x27;</span>)</span><br><span class="line">ny_time = utc_time.astimezone(ny_tz)</span><br></pre></td></tr></table></figure><h3 id="3-4-时区意识的日期时间对象"><a href="#3-4-时区意识的日期时间对象" class="headerlink" title="3.4 时区意识的日期时间对象"></a>3.4 时区意识的日期时间对象</h3><p>datetime 类提供了 replace() 方法，用于将日期时间对象变为时区意识的对象。</p><p><strong>创建时区意识的日期时间对象：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aware_time = datetime(<span class="number">2023</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>, tzinfo=pytz.timezone(<span class="string">&#x27;Europe/London&#x27;</span>))</span><br></pre></td></tr></table></figure><p>时区操作与切换功能强大，允许程序在不同的时区之间进行转换和处理，并且确保正确的时间显示和计算。在处理涉及不同时区的时间数据时，合理使用时区操作能够避免混淆和错误，并确保时间的准确性和一致性。</p><h3 id="示例-5：进行时区转换"><a href="#示例-5：进行时区转换" class="headerlink" title="示例 5：进行时区转换"></a>示例 5：进行时区转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line"></span><br><span class="line">utc_time = datetime.utcnow().replace(tzinfo=pytz.utc)</span><br><span class="line">local_timezone = pytz.timezone(<span class="string">&#x27;Asia/Shanghai&#x27;</span>)</span><br><span class="line"></span><br><span class="line">local_time = utc_time.astimezone(local_timezone)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Local Time:&quot;</span>, local_time)</span><br></pre></td></tr></table></figure><h2 id="4-结语"><a href="#4-结语" class="headerlink" title="4.结语"></a>4.结语</h2><p>datetime 和 time 模块为 Python 开发者提供了强大的时间和日期处理能力。通过这些模块，可以轻松地创建、操作和格式化日期时间，进行时间戳的转换，甚至处理时区等复杂操作。这些示例展示了如何使用这些模块来处理时间日期数据，为 Python 编程中时间处理提供了重要的参考和指导。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python 中的 datetime 和 time 模块为处理时间和日期提供了强大的功能。这些模块不仅支持时间和日期的操作，还能进行时间戳的转换、时区操作等。在本文中，我们将深入介绍这些模块的用法和实际示例。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="python" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/python/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>深入探究 Python 异步编程：利用 asyncio 和 aiohttp 构建高效并发应用</title>
    <link href="http://example.com/2023/12/10/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6-Python-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%9A%E5%88%A9%E7%94%A8-asyncio-%E5%92%8C-aiohttp-%E6%9E%84%E5%BB%BA%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%E5%BA%94%E7%94%A8/"/>
    <id>http://example.com/2023/12/10/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6-Python-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%9A%E5%88%A9%E7%94%A8-asyncio-%E5%92%8C-aiohttp-%E6%9E%84%E5%BB%BA%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%E5%BA%94%E7%94%A8/</id>
    <published>2023-12-10T08:44:49.000Z</published>
    <updated>2023-12-10T09:04:02.782Z</updated>
    
    <content type="html"><![CDATA[<p>在现代编程中，异步编程已成为处理高并发和IO密集型任务的重要方式。Python 提供了强大的异步编程支持，包括 asyncio 库和 aiohttp 等框架。本文将深入探讨异步编程的概念，以及在 Python 中如何利用异步框架来实现高效的并发编程。</p><span id="more"></span><h2 id="1-异步编程概念"><a href="#1-异步编程概念" class="headerlink" title="1.异步编程概念"></a>1.异步编程概念</h2><p>异步编程允许程序在等待 IO 操作完成时不被阻塞，而是继续执行其他任务。这种方式允许程序能够高效地处理大量并发任务，提高了系统的吞吐量和响应性。</p><h2 id="2-asyncio-库介绍"><a href="#2-asyncio-库介绍" class="headerlink" title="2.asyncio 库介绍"></a>2.asyncio 库介绍</h2><p>Python 的 asyncio 库是用于编写异步代码的核心模块。它提供了编写异步代码的工具和方法，并能够管理异步任务的执行。并且提供了 async&#x2F;await 语法来定义异步函数，以及事件循环来管理异步任务。</p><ul><li>asyncio 是 Python 标准库中的模块，用于支持异步编程。</li><li>它基于事件循环（Event Loop）机制，允许异步执行多个任务而无需线程。</li></ul><h3 id="2-1-async-x2F-await-语法示例"><a href="#2-1-async-x2F-await-语法示例" class="headerlink" title="2.1 async&#x2F;await 语法示例"></a>2.1 async&#x2F;await 语法示例</h3><ul><li>async&#x2F;await 是 Python 3.5 引入的语法，用于定义异步函数和等待异步任务完成。</li><li>async 关键字用于定义异步函数，await 用于等待异步任务的结果。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">example_coroutine</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, Async!&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-事件循环（Event-Loop）示例"><a href="#2-2-事件循环（Event-Loop）示例" class="headerlink" title="2.2 事件循环（Event Loop）示例"></a>2.2 事件循环（Event Loop）示例</h3><ul><li>事件循环是 asyncio 的核心概念，负责管理和调度异步任务的执行。</li><li>通过事件循环，可以调度任务并处理任务的完成或等待状态。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task = asyncio.create_task(example_coroutine())</span><br><span class="line">    result = <span class="keyword">await</span> task</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-异步任务"><a href="#2-3-异步任务" class="headerlink" title="2.3 异步任务"></a>2.3 异步任务</h3><ul><li>异步任务可以是 asyncio 中的协程函数（coroutine function）。</li><li>使用 asyncio.create_task() 或 asyncio.ensure_future() 创建异步任务。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">greet_async</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    result = <span class="keyword">await</span> greet_async(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4-asyncio-的优势和应用场景"><a href="#2-4-asyncio-的优势和应用场景" class="headerlink" title="2.4. asyncio 的优势和应用场景"></a>2.4. asyncio 的优势和应用场景</h3><ul><li>高并发性： asyncio 可以处理大量并发任务而无需创建大量线程。</li><li>IO 密集型任务： 适用于处理大量 IO 操作，如网络请求、文件读写等。</li><li>Web 开发： 能够构建高性能的 Web 服务器和客户端，与框架如 aiohttp 配合，提供异步的 HTTP 请求和响应。</li></ul><h2 id="3-aiohttp-框架"><a href="#3-aiohttp-框架" class="headerlink" title="3. aiohttp 框架"></a>3. aiohttp 框架</h2><p>aiohttp 是一个基于 asyncio 的 HTTP 客户端&#x2F;服务器框架。用于构建异步的 HTTP 客户端和服务器。它提供了简单易用的 API，使得编写高性能、可扩展的 Web 应用和处理异步 HTTP 请求变得更加方便。</p><h3 id="3-1-aiohttp-的主要特性"><a href="#3-1-aiohttp-的主要特性" class="headerlink" title="3.1. aiohttp 的主要特性"></a>3.1. aiohttp 的主要特性</h3><ul><li>基于 asyncio： 使用异步 IO 操作，能够充分利用异步编程的优势，处理大量并发请求。</li><li>支持 HTTP 客户端和服务器： 可用于构建异步的 Web 服务器和客户端。</li><li>WebSocket 支持： 提供了 WebSocket 客户端和服务器，用于实现实时通信。</li><li>中间件和拦截器： 支持中间件，可以在请求&#x2F;响应处理之前或之后执行一些操作。</li><li>SSL&#x2F;TLS 支持： 提供对加密通信的支持，保障数据安全。</li></ul><h3 id="3-2-使用-aiohttp-构建-HTTP-客户端"><a href="#3-2-使用-aiohttp-构建-HTTP-客户端" class="headerlink" title="3.2 使用 aiohttp 构建 HTTP 客户端"></a>3.2 使用 aiohttp 构建 HTTP 客户端</h3><h4 id="3-2-1-发送-GET-请求"><a href="#3-2-1-发送-GET-请求" class="headerlink" title="3.2.1 发送 GET 请求"></a>3.2.1 发送 GET 请求</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_data</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> response.text()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    url = <span class="string">&quot;https://jsonplaceholder.typicode.com/posts/1&quot;</span></span><br><span class="line">    result = <span class="keyword">await</span> fetch_data(url)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><h4 id="3-2-2-发送-POST请求"><a href="#3-2-2-发送-POST请求" class="headerlink" title="3.2.2 发送 POST请求"></a>3.2.2 发送 POST请求</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">send_data</span>(<span class="params">url, data</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.post(url, json=data) <span class="keyword">as</span> response:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> response.text()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    url = <span class="string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span></span><br><span class="line">    data = &#123;<span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;Example&#x27;</span>, <span class="string">&#x27;body&#x27;</span>: <span class="string">&#x27;Content&#x27;</span>&#125;</span><br><span class="line">    result = <span class="keyword">await</span> send_data(url, data)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><h3 id="3-3-构建-HTTP-服务器"><a href="#3-3-构建-HTTP-服务器" class="headerlink" title="3.3 构建 HTTP 服务器"></a>3.3 构建 HTTP 服务器</h3><h4 id="3-3-1-创建简单的-HTTP-服务器"><a href="#3-3-1-创建简单的-HTTP-服务器" class="headerlink" title="3.3.1 创建简单的 HTTP 服务器"></a>3.3.1 创建简单的 HTTP 服务器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> web.Response(text=<span class="string">&quot;Hello, aiohttp!&quot;</span>)</span><br><span class="line"></span><br><span class="line">app = web.Application()</span><br><span class="line">app.router.add_get(<span class="string">&#x27;/&#x27;</span>, handle)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    web.run_app(app)</span><br></pre></td></tr></table></figure><h4 id="3-3-2-添加路由和视图"><a href="#3-3-2-添加路由和视图" class="headerlink" title="3.3.2 添加路由和视图"></a>3.3.2 添加路由和视图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> web.Response(text=<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">request</span>):</span><br><span class="line">    name = request.match_info.get(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Anonymous&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> web.Response(text=<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">app = web.Application()</span><br><span class="line">app.router.add_get(<span class="string">&#x27;/&#x27;</span>, hello)</span><br><span class="line">app.router.add_get(<span class="string">&#x27;/greet/&#123;name&#125;&#x27;</span>, greet)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    web.run_app(app)</span><br></pre></td></tr></table></figure><h3 id="3-4-aiohttp-的应用场景"><a href="#3-4-aiohttp-的应用场景" class="headerlink" title="3.4. aiohttp 的应用场景"></a>3.4. aiohttp 的应用场景</h3><ul><li>Web 开发： 构建高性能、异步的 Web 服务器和客户端。</li><li>API 开发： 提供异步的 API 服务，处理大量请求。</li><li>实时通信： 使用 WebSocket 实现实时通信功能。</li></ul><h2 id="4-并发任务管理"><a href="#4-并发任务管理" class="headerlink" title="4. 并发任务管理"></a>4. 并发任务管理</h2><p>异步编程的优势在于能够处理大量并发任务。以下是异步编程中并发任务管理的一些关键概念和技巧：</p><h3 id="4-1-并发任务池asyncio-gather"><a href="#4-1-并发任务池asyncio-gather" class="headerlink" title="4.1 并发任务池asyncio.gather()"></a>4.1 并发任务池asyncio.gather()</h3><ul><li>asyncio.gather() 用于同时运行多个协程，并等待它们全部完成。</li><li>它接受一组协程作为参数，将它们提交到事件循环中执行，并在所有协程完成后返回结果。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">task_id</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Task <span class="subst">&#123;task_id&#125;</span> completed&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    tasks = [worker(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">    <span class="built_in">print</span>(results)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-2-asyncio-create-task"><a href="#4-2-asyncio-create-task" class="headerlink" title="4.2. asyncio.create_task()"></a>4.2. asyncio.create_task()</h3><ul><li>asyncio.create_task() 用于将单个协程转换为一个任务对象，可并发执行多个任务。</li><li>它将协程封装成任务对象，使其能够交给事件循环处理。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">task_id</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Task <span class="subst">&#123;task_id&#125;</span> completed&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task1 = asyncio.create_task(worker(<span class="number">1</span>))</span><br><span class="line">    task2 = asyncio.create_task(worker(<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(task1, task2)</span><br><span class="line">    <span class="built_in">print</span>(task1.result(), task2.result())</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-asyncio-ensure-future"><a href="#4-3-asyncio-ensure-future" class="headerlink" title="4.3. asyncio.ensure_future()"></a>4.3. asyncio.ensure_future()</h3><ul><li>asyncio.ensure_future() 将一个协程对象包装成一个任务对象。</li><li>这个方法不推荐在 Python 3.7 及以上版本中使用，因为它在 Python 3.7 中已经被标记为过时。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">task_id</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Task <span class="subst">&#123;task_id&#125;</span> completed&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task1 = asyncio.ensure_future(worker(<span class="number">1</span>))</span><br><span class="line">    task2 = asyncio.ensure_future(worker(<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(task1, task2)</span><br><span class="line">    <span class="built_in">print</span>(task1.result(), task2.result())</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-4-异步文件操作"><a href="#4-4-异步文件操作" class="headerlink" title="4.4 异步文件操作"></a>4.4 异步文件操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_file</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(file_path, mode=<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        contents = <span class="keyword">await</span> file.read()</span><br><span class="line">        <span class="built_in">print</span>(contents)</span><br><span class="line"></span><br><span class="line">asyncio.run(read_file(<span class="string">&#x27;example.txt&#x27;</span>))</span><br></pre></td></tr></table></figure><p>通过这些方法，可以方便地管理多个并发任务的执行，从而提高程序的效率和性能。异步框架 asyncio 提供了这些工具来简化并发任务的处理，使得异步编程变得更加高效和灵活。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>asyncio 能够使 Python 处理并发和异步任务变得更加简单和高效。它提供了一种非阻塞、基于事件的异步编程方式，适用于各种类型的应用和任务。</p><p>aiohttp 是一个强大且灵活的异步 HTTP 框架，适用于构建高性能的 Web 应用和处理异步 HTTP 请求。它允许开发者使用异步编程的优势来处理并发请求，提高了系统的性能和响应速度。</p><p>Python 的异步编程和并发性为处理高并发和IO密集型任务提供了强大的支持。通过 asyncio 和 aiohttp 等库，开发人员能够轻松地实现高效的异步编程，提高程序的性能和响应速度。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在现代编程中，异步编程已成为处理高并发和IO密集型任务的重要方式。Python 提供了强大的异步编程支持，包括 asyncio 库和 aiohttp 等框架。本文将深入探讨异步编程的概念，以及在 Python 中如何利用异步框架来实现高效的并发编程。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="python" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/python/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>深入探讨 Python 中的装饰器和上下文管理器</title>
    <link href="http://example.com/2023/12/04/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8-Python-%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>http://example.com/2023/12/04/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8-Python-%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/</id>
    <published>2023-12-04T14:35:19.000Z</published>
    <updated>2023-12-04T14:40:40.459Z</updated>
    
    <content type="html"><![CDATA[<p>Python 作为一门灵活而强大的语言，提供了许多高级特性，其中装饰器（Decorators）和上下文管理器（Context Managers）是其中两个非常有用的概念。这两个功能性特性提供了对代码结构和行为进行修改和控制的强大工具。它们允许程序员在不修改源代码的情况下，添加、修改或扩展函数或类的功能，帮助编写更优雅、更干净的代码，同时提高代码的可重用性和可维护性。</p><span id="more"></span><h3 id="装饰器（Decorators）"><a href="#装饰器（Decorators）" class="headerlink" title="装饰器（Decorators）"></a>装饰器（Decorators）</h3><p>装饰器是函数的函数，它接受一个函数作为参数，并返回一个新的函数。它们提供了一种简洁的方式来包装或修改函数的行为。通过装饰器，可以在不改变原始函数代码的情况下，添加额外的功能或逻辑，如日志记录、性能计时、权限检查等。这种能力使得装饰器成为Python中函数式编程范式的强大工具之一。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decorator_function</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 添加装饰逻辑</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">some_function</span>():</span><br><span class="line">    <span class="comment"># 函数体</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h4><p><strong>1. 计时器装饰器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Execution time: <span class="subst">&#123;end_time - start_time&#125;</span> seconds&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">some_function</span>():</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Function executed&quot;</span>)</span><br><span class="line"></span><br><span class="line">some_function()</span><br><span class="line"><span class="comment"># 输出：Function executed</span></span><br><span class="line"><span class="comment">#      Execution time: 2.000123 seconds</span></span><br></pre></td></tr></table></figure><p><strong>2. 权限检查装饰器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_permission</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> user_has_permission():</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> PermissionError(<span class="string">&quot;Permission denied&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@check_permission</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sensitive_operation</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Operation executed&quot;</span>)</span><br><span class="line"></span><br><span class="line">sensitive_operation()</span><br><span class="line"><span class="comment"># 如果用户有权限，输出：Operation executed</span></span><br><span class="line"><span class="comment"># 如果用户无权限，抛出 PermissionError</span></span><br></pre></td></tr></table></figure><h3 id="上下文管理器（Context-Managers）"><a href="#上下文管理器（Context-Managers）" class="headerlink" title="上下文管理器（Context Managers）"></a>上下文管理器（Context Managers）</h3><p>上下文管理器提供了对资源进行安全获取和释放的机制，即使在出现异常时也能确保资源的释放。这对于处理文件、数据库连接或其他需要资源管理的情况特别有用。上下文管理器可以使用 <code>with</code> 语句来确保在代码块执行前获取资源，在代码块执行后释放资源，保证资源的正确处理。</p><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomContextManager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 分配资源</span></span><br><span class="line">        <span class="keyword">return</span> resource</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_value, traceback</span>):</span><br><span class="line">        <span class="comment"># 释放资源</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> CustomContextManager() <span class="keyword">as</span> resource:</span><br><span class="line">    <span class="comment"># 使用资源的代码块</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="举例说明：-1"><a href="#举例说明：-1" class="headerlink" title="举例说明："></a>举例说明：</h4><p><strong>3. 文件操作的上下文管理器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileManager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, filename, mode</span>):</span><br><span class="line">        self.filename = filename</span><br><span class="line">        self.mode = mode</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        self.file = <span class="built_in">open</span>(self.filename, self.mode)</span><br><span class="line">        <span class="keyword">return</span> self.file</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_value, traceback</span>):</span><br><span class="line">        self.file.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> FileManager(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(<span class="string">&quot;Hello, Context Manager!&quot;</span>)</span><br><span class="line"><span class="comment"># 文件 example.txt 被正确地写入数据，并在代码块结束时自动关闭</span></span><br></pre></td></tr></table></figure><p><strong>4. 数据库连接的上下文管理器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseConnection</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, database</span>):</span><br><span class="line">        self.database = database</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        self.connection = sqlite3.connect(self.database)</span><br><span class="line">        <span class="keyword">return</span> self.connection</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_value, traceback</span>):</span><br><span class="line">        self.connection.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> DatabaseConnection(<span class="string">&quot;example.db&quot;</span>) <span class="keyword">as</span> conn:</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    cursor.execute(<span class="string">&quot;CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT)&quot;</span>)</span><br><span class="line"><span class="comment"># 在代码块中成功创建数据库连接，并在结束时自动关闭连接</span></span><br></pre></td></tr></table></figure><h3 id="高阶概念与应用"><a href="#高阶概念与应用" class="headerlink" title="高阶概念与应用"></a>高阶概念与应用</h3><p><strong>装饰器链</strong>：多个装饰器可以被串联使用，以添加多个功能。<br><strong>上下文管理器的异步支持</strong>：async with 语句在异步代码中管理异步资源的获取和释放。<br>这些高级特性提供了对 Python 代码逻辑和资源管理更细粒度的控制，使得代码更具灵活性和可维护性。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>装饰器和上下文管理器是 Python 中强大而灵活的特性，它们可以使代码更简洁、更易于维护，并且提供了许多便利。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python 作为一门灵活而强大的语言，提供了许多高级特性，其中装饰器（Decorators）和上下文管理器（Context Managers）是其中两个非常有用的概念。这两个功能性特性提供了对代码结构和行为进行修改和控制的强大工具。它们允许程序员在不修改源代码的情况下，添加、修改或扩展函数或类的功能，帮助编写更优雅、更干净的代码，同时提高代码的可重用性和可维护性。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="python" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/python/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>十大排序算法（十） - 希尔排序算法</title>
    <link href="http://example.com/2023/09/16/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2023/09/16/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2023-09-16T09:03:55.000Z</published>
    <updated>2023-09-16T09:30:09.077Z</updated>
    
    <content type="html"><![CDATA[<p>希尔排序（Shell Sort）是一种插入排序的改进算法，它通过比较相距一定间隔的元素进行排序，逐步减小间隔，最终实现整体有序。本文将详细介绍希尔排序的工作原理，提供示例和Python、Go、Java以及C语言的实现代码。</p><span id="more"></span><h3 id="希尔排序的基本思想"><a href="#希尔排序的基本思想" class="headerlink" title="希尔排序的基本思想"></a>希尔排序的基本思想</h3><p>希尔排序的核心思想是将整个待排序序列分割成若干个子序列，分别对这些子序列进行插入排序，然后逐步减小子序列的间隔，直到间隔为1，最终对整个序列进行一次插入排序。这样，插入排序的效率会得到大幅提升。</p><p>具体步骤如下：</p><ol><li><strong>确定间隔序列</strong>： 选择一个间隔序列，一般是逐步减半，直到间隔为1。</li><li><strong>间隔排序</strong>： 对间隔序列所对应的子序列进行插入排序。</li><li><strong>逐步缩小间隔</strong>： 重复第二步，逐步减小间隔，直到间隔为1，完成最终的插入排序。</li></ol><h3 id="希尔排序的示例"><a href="#希尔排序的示例" class="headerlink" title="希尔排序的示例"></a>希尔排序的示例</h3><p>让我们通过一个示例来理解希尔排序的工作原理。假设我们有一个整数数组 [12, 34, 54, 2, 3]，我们希望按升序排序它。</p><ol><li><strong>选择间隔序列</strong>： 假设我们选择间隔序列为 [2, 1]。</li><li><strong>间隔为2的排序</strong>： 分别对间隔为2的子序列进行插入排序。<ul><li>第一轮：[12, 3]  [34, 2]  [54]</li></ul></li><li><strong>间隔为1的排序</strong>： 对整个序列进行一次插入排序。<ul><li>第二轮：[3, 2, 12, 34, 54]<br>最终，我们得到了排序后的数组 [2, 3, 12, 34, 54]。</li></ul></li></ol><h3 id="希尔排序的时间复杂度"><a href="#希尔排序的时间复杂度" class="headerlink" title="希尔排序的时间复杂度"></a>希尔排序的时间复杂度</h3><p>希尔排序的时间复杂度取决于间隔序列的选择。一般来说，间隔序列的选择直接影响到希尔排序的性能。</p><ol><li><strong>最好情况时间复杂度</strong>： O(n log n)</li><li><strong>平均情况时间复杂度</strong>： 取决于间隔序列</li><li><strong>最坏情况时间复杂度</strong>： O(n^2)</li></ol><p>希尔排序是一种不稳定的排序算法，适用于中等大小的数据集。它是插入排序的改进版本，通过减小元素移动的距离来提高排序效率。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是希尔排序的示例代码，分别使用Python、Go、Java和C语言编写。</p><p><strong>Python 希尔排序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shell_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, n):</span><br><span class="line">            temp = arr[i]</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> j &gt;= gap <span class="keyword">and</span> arr[j - gap] &gt; temp:</span><br><span class="line">                arr[j] = arr[j - gap]</span><br><span class="line">                j -= gap</span><br><span class="line">            arr[j] = temp</span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">arr = [<span class="number">12</span>, <span class="number">34</span>, <span class="number">54</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">shell_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的数组:&quot;</span>, arr)</span><br></pre></td></tr></table></figure><p><strong>Go 希尔排序</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shellSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(arr)</span><br><span class="line">gap := n / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> gap &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := gap; i &lt; n; i++ &#123;</span><br><span class="line">temp := arr[i]</span><br><span class="line">j := i</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j &gt;= gap &amp;&amp; arr[j-gap] &gt; temp &#123;</span><br><span class="line">arr[j] = arr[j-gap]</span><br><span class="line">j -= gap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[j] = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gap /= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := []<span class="type">int</span>&#123;<span class="number">12</span>, <span class="number">34</span>, <span class="number">54</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">shellSort(arr)</span><br><span class="line">fmt.Println(<span class="string">&quot;排序后的数组:&quot;</span>, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 希尔排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span> arr[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp) &#123;</span><br><span class="line">                    arr[j] = arr[j - gap];</span><br><span class="line">                    j -= gap;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            gap /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">34</span>, <span class="number">54</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        shellSort(arr);</span><br><span class="line">        System.out.print(<span class="string">&quot;排序后的数组: &quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C 语言 希尔排序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> gap = n / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = arr[i];</span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp) &#123;</span><br><span class="line">                arr[j] = arr[j - gap];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">34</span>, <span class="number">54</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    shellSort(arr, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上示例代码展示了不同编程语言中的希尔排序算法实现。这些示例帮助你理解希尔排序的工作原理，并提供了可供参考和使用的代码示例。希尔排序是一种高效的排序算法，可以在大多数情况下获得不错的性能。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;希尔排序（Shell Sort）是一种插入排序的改进算法，它通过比较相距一定间隔的元素进行排序，逐步减小间隔，最终实现整体有序。本文将详细介绍希尔排序的工作原理，提供示例和Python、Go、Java以及C语言的实现代码。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>十大排序算法（九） - 基数排序算法</title>
    <link href="http://example.com/2023/09/16/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2023/09/16/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2023-09-16T09:03:36.000Z</published>
    <updated>2023-09-16T09:29:01.054Z</updated>
    
    <content type="html"><![CDATA[<p>基数排序（Radix Sort）是一种非比较性的排序算法，它将整数按位数逐个排序，每个位数的排序采用稳定的排序算法，最终得到有序序列。本文将详细介绍基数排序的工作原理，提供示例和Python、Go、Java以及C语言的实现代码。</p><span id="more"></span><h3 id="基数排序的基本思想"><a href="#基数排序的基本思想" class="headerlink" title="基数排序的基本思想"></a>基数排序的基本思想</h3><p>基数排序的核心思想是将整数按位数切割成不同的数字，然后按每个位上的数字分组。具体步骤如下：</p><ol><li>确定位数： 确定待排序整数的最大位数，作为排序的轮数。</li><li>按位分组： 将整数按位数分成个位、十位、百位等不同组，从最低位开始。</li><li>每个位上的排序： 对每个位上的数字进行稳定排序，可以选择计数排序等。</li><li>合并： 合并每个位上的数字，得到最终有序序列。</li></ol><h3 id="基数排序的示例"><a href="#基数排序的示例" class="headerlink" title="基数排序的示例"></a>基数排序的示例</h3><p>让我们通过一个示例来理解基数排序的工作原理。假设我们有一个整数数组 [170, 45, 75, 90, 802, 24, 2, 66]，我们希望按升序排序它。</p><ol><li><strong>确定位数</strong>： 最大整数是802，有3位数字，因此需要3轮排序。</li><li><strong>按位分组</strong>： 将整数按个位数字分组。<ul><li>桶0: [170, 90]</li><li>桶1: [801]</li><li>桶2: [802, 2]</li><li>桶3: []</li><li>桶4: []</li><li>桶5: [75]</li><li>桶6: [66]</li><li>桶7: []</li><li>桶8: []</li><li>桶9: [45, 24]</li></ul></li><li><strong>每个位上的排序</strong>： 对每个位上的数字进行稳定排序，这里选择计数排序。<ul><li>第一轮（个位）： 170, 90, 801, 802, 2, 75, 66, 45, 24</li><li>第二轮（十位）： 801, 802, 2, 24, 45, 66, 75, 170, 90</li><li>第三轮（百位）： 2, 24, 45, 66, 75, 90, 170, 801, 802</li></ul></li><li><strong>合并</strong>： 得到最终有序序列。<ul><li>排序后的数组: [2, 24, 45, 66, 75, 90, 170, 801, 802]</li></ul></li></ol><h3 id="基数排序的时间复杂度"><a href="#基数排序的时间复杂度" class="headerlink" title="基数排序的时间复杂度"></a>基数排序的时间复杂度</h3><p>基数排序的时间复杂度取决于稳定排序算法的时间复杂度以及位数。假设n是待排序元素的数量，k是元素的位数，t是稳定排序算法的时间复杂度。</p><ol><li><strong>每位的排序时间</strong>： O(n + t)</li><li><strong>总的排序时间</strong>： O(k * (n + t))<br>综合起来，基数排序的时间复杂度为O(k * (n + t))。</li></ol><p>基数排序是一种稳定的排序算法，适用于整数排序。它在元素位数较小且范围确定的情况下表现出色。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是基数排序的示例代码，分别使用Python、Go、Java和C语言编写。</p><p><strong>Python 基数排序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">counting_sort</span>(<span class="params">arr, exp</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    output = [<span class="number">0</span>] * n</span><br><span class="line">    count = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 统计每个位上的数字出现次数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        index = arr[i] // exp</span><br><span class="line">        count[index % <span class="number">10</span>] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算累积频次</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据位数排序</span></span><br><span class="line">    i = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">        index = arr[i] // exp</span><br><span class="line">        output[count[index % <span class="number">10</span>] - <span class="number">1</span>] = arr[i]</span><br><span class="line">        count[index % <span class="number">10</span>] -= <span class="number">1</span></span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将排序结果复制回原数组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        arr[i] = output[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">radix_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    max_num = <span class="built_in">max</span>(arr)</span><br><span class="line">    exp = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> max_num // exp &gt; <span class="number">0</span>:</span><br><span class="line">        counting_sort(arr, exp)</span><br><span class="line">        exp *= <span class="number">10</span></span><br><span class="line"></span><br><span class="line">arr = [<span class="number">170</span>, <span class="number">45</span>, <span class="number">75</span>, <span class="number">90</span>, <span class="number">802</span>, <span class="number">24</span>, <span class="number">2</span>, <span class="number">66</span>]</span><br><span class="line">radix_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的数组:&quot;</span>, arr)</span><br></pre></td></tr></table></figure><p><strong>Go 基数排序</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countingSort</span><span class="params">(arr []<span class="type">int</span>, exp <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(arr)</span><br><span class="line">output := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">count := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计每个位上的数字出现次数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">index := arr[i] / exp % <span class="number">10</span></span><br><span class="line">count[index]++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算累积频次</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">count[i] += count[i<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据位数排序</span></span><br><span class="line"><span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">index := arr[i] / exp % <span class="number">10</span></span><br><span class="line">output[count[index]<span class="number">-1</span>] = arr[i]</span><br><span class="line">count[index]--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将排序结果复制回原数组</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">arr[i] = output[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">radixSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">maxNum := arr[<span class="number">0</span>]</span><br><span class="line">n := <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到最大值</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> arr[i] &gt; maxNum &#123;</span><br><span class="line">maxNum = arr[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exp := <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐位排序</span></span><br><span class="line"><span class="keyword">for</span> maxNum/exp &gt; <span class="number">0</span> &#123;</span><br><span class="line">countingSort(arr, exp)</span><br><span class="line">exp *= <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := []<span class="type">int</span>&#123;<span class="number">170</span>, <span class="number">45</span>, <span class="number">75</span>, <span class="number">90</span>, <span class="number">802</span>, <span class="number">24</span>, <span class="number">2</span>, <span class="number">66</span>&#125;</span><br><span class="line">radixSort(arr)</span><br><span class="line">fmt.Println(<span class="string">&quot;排序后的数组:&quot;</span>, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 基数排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> exp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> output[] = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> count[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计每个位上的数字出现次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> arr[i] / exp % <span class="number">10</span>;</span><br><span class="line">            count[index]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算累积频次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据位数排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> arr[i] / exp % <span class="number">10</span>;</span><br><span class="line">            output[count[index] - <span class="number">1</span>] = arr[i];</span><br><span class="line">            count[index]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将排序结果复制回原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = output[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span> arr[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> Arrays.stream(arr).max().getAsInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (maxNum / exp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            countingSort(arr, exp);</span><br><span class="line">            exp *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">170</span>, <span class="number">45</span>, <span class="number">75</span>, <span class="number">90</span>, <span class="number">802</span>, <span class="number">24</span>, <span class="number">2</span>, <span class="number">66</span>&#125;;</span><br><span class="line">        radixSort(arr);</span><br><span class="line">        System.out.print(<span class="string">&quot;排序后的数组: &quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C 语言 基数排序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> <span class="built_in">exp</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> output[n];</span><br><span class="line">    <span class="type">int</span> count[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计每个位上的数字出现次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        count[(arr[i] / <span class="built_in">exp</span>) % <span class="number">10</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算累积频次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据位数排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        output[count[(arr[i] / <span class="built_in">exp</span>) % <span class="number">10</span>] - <span class="number">1</span>] = arr[i];</span><br><span class="line">        count[(arr[i] / <span class="built_in">exp</span>) % <span class="number">10</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将排序结果复制回原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] = output[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxNum = arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; maxNum) &#123;</span><br><span class="line">            maxNum = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="built_in">exp</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐位排序</span></span><br><span class="line">    <span class="keyword">while</span> (maxNum / <span class="built_in">exp</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        countingSort(arr, n, <span class="built_in">exp</span>);</span><br><span class="line">        <span class="built_in">exp</span> *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">170</span>, <span class="number">45</span>, <span class="number">75</span>, <span class="number">90</span>, <span class="number">802</span>, <span class="number">24</span>, <span class="number">2</span>, <span class="number">66</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    radixSort(arr, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上示例代码展示了不同编程语言中的基数排序算法实现。这些示例帮助你理解基数排序的工作原理，并提供了可供参考和使用的代码示例。基数排序是一种适用于整数排序的高效稳定的排序算法。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基数排序（Radix Sort）是一种非比较性的排序算法，它将整数按位数逐个排序，每个位数的排序采用稳定的排序算法，最终得到有序序列。本文将详细介绍基数排序的工作原理，提供示例和Python、Go、Java以及C语言的实现代码。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>十大排序算法（八） - 桶排序算法</title>
    <link href="http://example.com/2023/09/16/%E6%A1%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2023/09/16/%E6%A1%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2023-09-16T09:03:18.000Z</published>
    <updated>2023-09-16T09:29:20.358Z</updated>
    
    <content type="html"><![CDATA[<p>桶排序（Bucket Sort）是一种分布式排序算法，它根据元素的值将它们分散到不同的桶中，并对每个桶中的元素进行排序。最后，将所有非空桶的元素按照顺序合并成排序后的数组。本文将详细介绍桶排序的工作原理，提供示例和Python、Go、Java以及C语言的实现代码。</p><span id="more"></span><h3 id="桶排序的基本思想"><a href="#桶排序的基本思想" class="headerlink" title="桶排序的基本思想"></a>桶排序的基本思想</h3><p>桶排序的核心思想是将待排序的元素根据其值分配到不同的桶中，然后对每个桶中的元素进行独立排序，最后将所有桶合并为一个有序序列。</p><p>具体步骤如下：</p><ol><li><strong>桶的设置</strong>： 根据待排序元素的特性，确定需要设置多少个桶以及每个桶的范围。</li><li><strong>元素分配</strong>： 将待排序元素根据其值分配到相应的桶中。</li><li><strong>每个桶排序</strong>： 对每个非空桶中的元素进行独立排序，可以选择不同的排序算法。</li><li><strong>桶的合并</strong>： 将所有非空桶中的元素合并成排序后的数组。</li></ol><h3 id="桶排序的示例"><a href="#桶排序的示例" class="headerlink" title="桶排序的示例"></a>桶排序的示例</h3><p>让我们通过一个示例来理解桶排序的工作原理。假设我们有一个浮点数数组 [0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434]，我们希望按升序排序它。</p><ol><li><strong>设置桶</strong>： 假设我们设置3个桶，分别对应范围[0, 0.3333), [0.3333, 0.6666), [0.6666, 1.0)。</li><li><strong>元素分配</strong>： 将元素分配到对应的桶中。<ul><li>桶1: [0.1234]</li><li>桶2: [0.565, 0.656]</li><li>桶3: [0.897, 0.665, 0.3434]</li></ul></li><li><strong>每个桶排序</strong>： 对每个桶中的元素进行排序。<ul><li>桶1: [0.1234]</li><li>桶2: [0.565, 0.656]</li><li>桶3: [0.3434, 0.665, 0.897]</li></ul></li><li><strong>桶的合并</strong>： 将所有非空桶中的元素合并成排序后的数组。<ul><li>排序后的数组: [0.1234, 0.3434, 0.565, 0.656, 0.665, 0.897]</li></ul></li></ol><h3 id="桶排序的时间复杂度"><a href="#桶排序的时间复杂度" class="headerlink" title="桶排序的时间复杂度"></a>桶排序的时间复杂度</h3><p>桶排序的时间复杂度取决于桶的数量和每个桶中元素的排序算法。假设n是待排序元素的数量，k是桶的数量，t是桶内排序的平均时间复杂度。</p><ol><li>桶分配时间： O(n)</li><li>每个桶内排序时间： O(k * t)</li><li>桶的合并时间： O(n)<br>综合起来，桶排序的时间复杂度为O(n + k * t)，其中k和t取决于具体实现和数据分布。</li></ol><p>桶排序是一种稳定的排序算法，适用于分布均匀的数据。它在对浮点数等分布广泛的数据排序时表现出色。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是桶排序的示例代码，分别使用Python、Go、Java和C语言编写。</p><p><strong>Python 桶排序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bucket_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="comment"># 确定桶的数量</span></span><br><span class="line">    num_buckets = <span class="built_in">len</span>(arr)</span><br><span class="line">    buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_buckets)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将元素分配到对应的桶中</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">        bucket_index = <span class="built_in">int</span>(num * num_buckets)</span><br><span class="line">        buckets[bucket_index].append(num)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对每个非空桶进行排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_buckets):</span><br><span class="line">        buckets[i].sort()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并桶</span></span><br><span class="line">    sorted_arr = []</span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">        sorted_arr.extend(bucket)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sorted_arr</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">0.897</span>, <span class="number">0.565</span>, <span class="number">0.656</span>, <span class="number">0.1234</span>, <span class="number">0.665</span>, <span class="number">0.3434</span>]</span><br><span class="line">sorted_arr = bucket_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的数组:&quot;</span>, sorted_arr)</span><br></pre></td></tr></table></figure><p><strong>Go 桶排序</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketSort</span><span class="params">(arr []<span class="type">float64</span>)</span></span> []<span class="type">float64</span> &#123;</span><br><span class="line">numBuckets := <span class="built_in">len</span>(arr)</span><br><span class="line">buckets := <span class="built_in">make</span>([][]<span class="type">float64</span>, numBuckets)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素分配到对应的桶中</span></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> arr &#123;</span><br><span class="line">bucketIndex := <span class="type">int</span>(num * <span class="type">float64</span>(numBuckets))</span><br><span class="line">buckets[bucketIndex] = <span class="built_in">append</span>(buckets[bucketIndex], num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对每个非空桶进行排序</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numBuckets; i++ &#123;</span><br><span class="line">sort.Float64s(buckets[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并桶</span></span><br><span class="line">sortedArr := <span class="built_in">make</span>([]<span class="type">float64</span>, <span class="number">0</span>, <span class="built_in">len</span>(arr))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numBuckets; i++ &#123;</span><br><span class="line">sortedArr = <span class="built_in">append</span>(sortedArr, buckets[i]...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sortedArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := []<span class="type">float64</span>&#123;<span class="number">0.897</span>, <span class="number">0.565</span>, <span class="number">0.656</span>, <span class="number">0.1234</span>, <span class="number">0.665</span>, <span class="number">0.3434</span>&#125;</span><br><span class="line">sortedArr := bucketSort(arr)</span><br><span class="line">fmt.Println(<span class="string">&quot;排序后的数组:&quot;</span>, sortedArr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 桶排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span>[] bucketSort(<span class="type">double</span>[] arr) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numBuckets</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        List&lt;Double&gt;[] buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[numBuckets];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numBuckets; i++) &#123;</span><br><span class="line">            buckets[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将元素分配到对应的桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">double</span> num : arr) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bucketIndex</span> <span class="operator">=</span> (<span class="type">int</span>) (num * numBuckets);</span><br><span class="line">            buckets[bucketIndex].add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对每个非空桶进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numBuckets; i++) &#123;</span><br><span class="line">            buckets[i].sort(Double::compare);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并桶</span></span><br><span class="line">        <span class="type">double</span>[] sortedArr = <span class="keyword">new</span> <span class="title class_">double</span>[arr.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numBuckets; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">double</span> num : buckets[i]) &#123;</span><br><span class="line">                sortedArr[index++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sortedArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span>[] arr = &#123;<span class="number">0.897</span>, <span class="number">0.565</span>, <span class="number">0.656</span>, <span class="number">0.1234</span>, <span class="number">0.665</span>, <span class="number">0.3434</span>&#125;;</span><br><span class="line">        <span class="type">double</span>[] sortedArr = bucketSort(arr);</span><br><span class="line">        System.out.print(<span class="string">&quot;排序后的数组: &quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(sortedArr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C 语言 桶排序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Bucket</span> &#123;</span></span><br><span class="line">    Node *head;</span><br><span class="line">&#125; Bucket;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span>* <span class="title function_">bucketSort</span><span class="params">(<span class="type">double</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 确定桶的数量</span></span><br><span class="line">    <span class="type">int</span> numBuckets = n;</span><br><span class="line">    Bucket *buckets = (Bucket *)<span class="built_in">malloc</span>(numBuckets * <span class="keyword">sizeof</span>(Bucket));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化桶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numBuckets; i++) &#123;</span><br><span class="line">        buckets[i].head = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素分配到对应的桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> bucketIndex = (<span class="type">int</span>)(arr[i] * numBuckets);</span><br><span class="line">        Node *node = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        node-&gt;data = arr[i];</span><br><span class="line">        node-&gt;next = buckets[bucketIndex].head;</span><br><span class="line">        buckets[bucketIndex].head = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并桶并获取排序后的数组</span></span><br><span class="line">    <span class="type">double</span> *sortedArr = (<span class="type">double</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numBuckets; i++) &#123;</span><br><span class="line">        Node *current = buckets[i].head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sortedArr[index++] = current-&gt;data;</span><br><span class="line">            Node *temp = current;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(buckets);</span><br><span class="line">    <span class="keyword">return</span> sortedArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> arr[] = &#123;<span class="number">0.897</span>, <span class="number">0.565</span>, <span class="number">0.656</span>, <span class="number">0.1234</span>, <span class="number">0.665</span>, <span class="number">0.3434</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">double</span> *sortedArr = bucketSort(arr, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.4f &quot;</span>, sortedArr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(sortedArr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上示例代码展示了不同编程语言中的桶排序算法实现。这些示例帮助你理解桶排序的工作原理，并提供了可供参考和使用的代码示例。桶排序是一种适用于分布广泛数据的高效排序算法。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;桶排序（Bucket Sort）是一种分布式排序算法，它根据元素的值将它们分散到不同的桶中，并对每个桶中的元素进行排序。最后，将所有非空桶的元素按照顺序合并成排序后的数组。本文将详细介绍桶排序的工作原理，提供示例和Python、Go、Java以及C语言的实现代码。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>十大排序算法（七） - 计数排序算法</title>
    <link href="http://example.com/2023/09/16/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2023/09/16/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2023-09-16T09:03:02.000Z</published>
    <updated>2023-09-16T09:28:47.959Z</updated>
    
    <content type="html"><![CDATA[<p>计数排序（Counting Sort）是一种简单、高效的排序算法，它不基于比较，而是利用数组下标的计数来实现排序。本文将详细介绍计数排序的工作原理，提供示例和Python、Go、Java以及C语言的实现代码。</p><span id="more"></span><h3 id="计数排序的基本思想"><a href="#计数排序的基本思想" class="headerlink" title="计数排序的基本思想"></a>计数排序的基本思想</h3><p>计数排序的核心思想是统计数组中每个元素的出现次数，然后根据元素的大小依次放置到有序的结果数组中。具体步骤如下：</p><ol><li><strong>统计频次</strong>： 遍历待排序数组，统计每个元素出现的频次，以数组的值为索引。</li><li><strong>计算累积频次</strong>： 计算每个元素的累积频次，确定元素在排序数组中的位置。</li><li><strong>构建有序数组</strong>： 根据元素的累积频次，将元素放入有序数组中，同时更新累积频次。</li></ol><p>计数排序的关键在于构建辅助数组，辅助数组用于存储每个元素的出现次数，以及计算每个元素在排序后的数组中的位置。</p><h3 id="计数排序的示例"><a href="#计数排序的示例" class="headerlink" title="计数排序的示例"></a>计数排序的示例</h3><p>让我们通过一个示例来理解计数排序的工作原理。假设我们有一个整数数组 [3, 1, 4, 1, 5, 9, 2, 6, 5]，我们希望按升序排序它。</p><ol><li><strong>统计频次</strong>： 统计每个元素的出现次数。<ul><li>待排序数组： [3, 1, 4, 1, 5, 9, 2, 6, 5]</li><li>频次数组：   [0, 1, 1, 1, 2, 1, 1, 0, 1]</li></ul></li><li><strong>计算累积频次</strong>： 计算每个元素的累积频次。<ul><li>累积频次数组： [0, 1, 2, 3, 5, 6, 7, 7, 8]</li></ul></li><li><strong>构建有序数组</strong>： 根据元素的累积频次，将元素放入有序数组中。<ul><li>排序后的数组： [1, 1, 2, 3, 4, 5, 5, 6, 9]</li></ul></li></ol><h3 id="计数排序的时间复杂度"><a href="#计数排序的时间复杂度" class="headerlink" title="计数排序的时间复杂度"></a>计数排序的时间复杂度</h3><p>计数排序的时间复杂度为O(n + k)，其中n是数组的长度，k是数组中元素的取值范围。计数排序的时间复杂度非常稳定，性能优异，尤其适合对整数进行排序。但需要注意，计数排序仅适用于非负整数或确定范围的整数排序。</p><p>计数排序是一种稳定的排序算法，通过对元素的频次统计和累积频次计算，实现了线性时间的排序。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是计数排序的示例代码，分别使用Python、Go、Java和C语言编写。</p><p><strong>Python 计数排序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">counting_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    max_val = <span class="built_in">max</span>(arr)</span><br><span class="line">    counts = [<span class="number">0</span>] * (max_val + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 统计每个元素的频次</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">        counts[num] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算每个元素的累积频次</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, max_val + <span class="number">1</span>):</span><br><span class="line">        counts[i] += counts[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建有序数组</span></span><br><span class="line">    sorted_arr = [<span class="number">0</span>] * <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        sorted_arr[counts[arr[i]] - <span class="number">1</span>] = arr[i]</span><br><span class="line">        counts[arr[i]] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sorted_arr</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>]</span><br><span class="line">sorted_arr = counting_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的数组:&quot;</span>, sorted_arr)</span><br></pre></td></tr></table></figure><p><strong>Go 计数排序</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countingSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    maxVal := arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        <span class="keyword">if</span> num &gt; maxVal &#123;</span><br><span class="line">            maxVal = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    counts := <span class="built_in">make</span>([]<span class="type">int</span>, maxVal+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计每个元素的频次</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        counts[num]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个元素的累积频次</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= maxVal; i++ &#123;</span><br><span class="line">        counts[i] += counts[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建有序数组</span></span><br><span class="line">    sortedArr := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(arr))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(arr) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        sortedArr[counts[arr[i]]<span class="number">-1</span>] = arr[i]</span><br><span class="line">        counts[arr[i]]--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sortedArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>&#125;</span><br><span class="line">    sortedArr := countingSort(arr)</span><br><span class="line">    fmt.Println(<span class="string">&quot;排序后的数组:&quot;</span>, sortedArr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 计数排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountingSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] countingSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxVal</span> <span class="operator">=</span> Arrays.stream(arr).max().getAsInt();</span><br><span class="line">        <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[maxVal + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计每个元素的频次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            counts[num]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算每个元素的累积频次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= maxVal; i++) &#123;</span><br><span class="line">            counts[i] += counts[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建有序数组</span></span><br><span class="line">        <span class="type">int</span>[] sortedArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            sortedArr[counts[arr[i]] - <span class="number">1</span>] = arr[i];</span><br><span class="line">            counts[arr[i]]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sortedArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] sortedArr = countingSort(arr);</span><br><span class="line">        System.out.print(<span class="string">&quot;排序后的数组: &quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(sortedArr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C 语言 计数排序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxVal = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; maxVal) &#123;</span><br><span class="line">            maxVal = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *counts = (<span class="type">int</span> *)<span class="built_in">malloc</span>((maxVal + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> *sortedArr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化计数数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= maxVal; i++) &#123;</span><br><span class="line">        counts[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计每个元素的频次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        counts[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个元素的累积频次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= maxVal; i++) &#123;</span><br><span class="line">        counts[i] += counts[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建有序数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        sortedArr[counts[arr[i]] - <span class="number">1</span>] = arr[i];</span><br><span class="line">        counts[arr[i]]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将有序数组拷贝回原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] = sortedArr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(counts);</span><br><span class="line">    <span class="built_in">free</span>(sortedArr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    countingSort(arr, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上示例代码展示了不同编程语言中的计数排序算法实现。这些示例帮助你理解计数排序的工作原理，并提供了可供参考和使用的代码示例。计数排序是一种稳定且高效的排序算法，尤其适用于整数排序。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;计数排序（Counting Sort）是一种简单、高效的排序算法，它不基于比较，而是利用数组下标的计数来实现排序。本文将详细介绍计数排序的工作原理，提供示例和Python、Go、Java以及C语言的实现代码。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>十大排序算法（六） - 堆排序算法</title>
    <link href="http://example.com/2023/09/14/%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2023/09/14/%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2023-09-14T14:12:37.000Z</published>
    <updated>2023-09-16T09:28:37.325Z</updated>
    
    <content type="html"><![CDATA[<p>堆排序（Heap Sort）是一种高效的、基于堆数据结构的排序算法，它具有稳定性和可预测的性能，适用于各种数据规模。本文将详细介绍堆排序的工作原理，提供示例和Python、Go、Java以及C语言的实现代码。</p><span id="more"></span><h3 id="堆排序的基本思想"><a href="#堆排序的基本思想" class="headerlink" title="堆排序的基本思想"></a>堆排序的基本思想</h3><p>堆排序的核心思想是通过构建一个二叉堆，将待排序的数组转换为一个堆，然后反复从堆中取出最大（或最小）的元素，并将其放入已排序的部分。具体步骤如下：</p><ol><li><strong>构建堆</strong>： 将待排序的数组视为一个完全二叉树，并将其调整为一个堆，通常是一个最大堆（每个节点的值大于或等于其子节点的值）或最小堆（每个节点的值小于或等于其子节点的值）。</li><li><strong>取出根节点</strong>： 从堆中取出根节点元素，它是堆中的最大（或最小）元素。</li><li><strong>重建堆</strong>： 删除根节点后，将堆重新调整为合法的堆结构。</li><li><strong>重复操作</strong>： 重复步骤2和步骤3，直到堆中的元素为空。已经取出的元素会构成已排序部分。</li><li><strong>返回结果</strong>： 最终得到一个完全有序的数组。</li></ol><p>堆排序的关键在于构建堆和维护堆的性质，以确保每次取出的元素都是堆中的最大（或最小）元素。这一过程使得堆排序的时间复杂度保持在O(n*log(n))，并且在实际应用中表现出色。</p><h3 id="堆排序的示例"><a href="#堆排序的示例" class="headerlink" title="堆排序的示例"></a>堆排序的示例</h3><p>让我们通过一个示例来理解堆排序的工作原理。假设我们有一个整数数组 [5, 2, 9, 3, 4]，我们希望按升序排序它。</p><ol><li><strong>构建堆</strong>：首先将数组 [5, 2, 9, 3, 4] 转换为一个最大堆。最大堆的性质是父节点的值大于或等于其子节点的值。<ul><li>原始数组：[5, 2, 9, 3, 4]</li><li>最大堆：[9, 4, 5, 3, 2]</li></ul></li><li><strong>取出根节点</strong>：取出堆的根节点元素，即 9，并将其放入已排序的部分。</li><li><strong>重建堆</strong>：删除根节点后，重新调整堆结构，确保其满足最大堆的性质。<ul><li>剩余堆：[5, 4, 2, 3]</li></ul></li><li><strong>重复操作</strong>：重复步骤2和步骤3，直到堆中的元素为空。已经取出的元素会构成已排序部分。这个过程得到了一个升序排列的已排序数组 [2, 3, 4, 5, 9]。</li></ol><h3 id="堆排序的时间复杂度"><a href="#堆排序的时间复杂度" class="headerlink" title="堆排序的时间复杂度"></a>堆排序的时间复杂度</h3><p>堆排序的时间复杂度保持在O(n*log(n))，其中n是数组的长度。这使得它在处理大型数据集时具有出色的性能。堆排序不需要额外的存储空间，因此具有O(1)的空间复杂度。</p><p>堆排序的稳定性取决于堆的性质。如果使用最大堆来进行排序，相同元素的相对顺序可能会发生变化，因此它通常是不稳定的排序算法。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是堆排序的示例代码，分别使用Python、Go、Java和C语言编写。</p><p><strong>Python 堆排序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">heapify</span>(<span class="params">arr, n, i</span>):</span><br><span class="line">    largest = i</span><br><span class="line">    left = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    right = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> left &lt; n <span class="keyword">and</span> arr[left] &gt; arr[largest]:</span><br><span class="line">        largest = left</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> right &lt; n <span class="keyword">and</span> arr[right] &gt; arr[largest]:</span><br><span class="line">        largest = right</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> largest != i:</span><br><span class="line">        arr[i], arr[largest] = arr[largest], arr[i]</span><br><span class="line">        heapify(arr, n, largest)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n // <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        heapify(arr, n, i)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 逐个取出堆中的元素并排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i]</span><br><span class="line">        heapify(arr, i, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">heap_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的数组:&quot;</span>, arr)</span><br></pre></td></tr></table></figure><p><strong>Go 堆排序</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapify</span><span class="params">(arr []<span class="type">int</span>, n <span class="type">int</span>, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    largest := i</span><br><span class="line">    left := <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">    right := <span class="number">2</span>*i + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> left &lt; n &amp;&amp; arr[left] &gt; arr[largest] &#123;</span><br><span class="line">        largest = left</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> right &lt; n &amp;&amp; arr[right] &gt; arr[largest] &#123;</span><br><span class="line">        largest = right</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> largest != i &#123;</span><br><span class="line">        arr[i], arr[largest] = arr[largest], arr[i]</span><br><span class="line">        heapify(arr, n, largest)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> i := n/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        heapify(arr, n, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐个取出堆中的元素并排序</span></span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i]</span><br><span class="line">        heapify(arr, i, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    heapSort(arr)</span><br><span class="line">    fmt.Println(<span class="string">&quot;排序后的数组:&quot;</span>, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 堆排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> n, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">swap</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[largest];</span><br><span class="line">            arr[largest] = swap;</span><br><span class="line"></span><br><span class="line">            heapify(arr, n, largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建最大堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapify(arr, n, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐个取出堆中的元素并排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line"></span><br><span class="line">            heapify(arr, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        heapSort(arr);</span><br><span class="line">        System.out.print(<span class="string">&quot;排序后的数组: &quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C 语言 堆排序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">int</span> largest = i;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[largest];</span><br><span class="line">        arr[largest] = temp;</span><br><span class="line"></span><br><span class="line">        heapify(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 构建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐个取出堆中的元素并排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line"></span><br><span class="line">        heapify(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    heapSort(arr, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上示例代码展示了不同编程语言中的堆排序算法实现。这些示例帮助你理解堆排序的工作原理，并提供了可供参考和使用的代码示例。堆排序是一种高效且稳定的排序算法，适用于各种应用场景，特别适合对大型数据集进行排序。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;堆排序（Heap Sort）是一种高效的、基于堆数据结构的排序算法，它具有稳定性和可预测的性能，适用于各种数据规模。本文将详细介绍堆排序的工作原理，提供示例和Python、Go、Java以及C语言的实现代码。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>十大排序算法（五） - 归并排序算法</title>
    <link href="http://example.com/2023/09/14/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2023/09/14/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2023-09-14T14:12:22.000Z</published>
    <updated>2023-09-16T09:28:29.739Z</updated>
    
    <content type="html"><![CDATA[<p>归并排序（Merge Sort）是一种高效的、基于分治法的排序算法，它的稳定性和性能使其成为常用的排序方法之一。本文将详细介绍归并排序的工作原理，提供示例和Python、Go、Java以及C语言的实现代码。</p><span id="more"></span><h3 id="归并排序的基本思想"><a href="#归并排序的基本思想" class="headerlink" title="归并排序的基本思想"></a>归并排序的基本思想</h3><p>归并排序的核心思想是将数组分成两个子数组，递归地对这两个子数组进行排序，然后将它们合并成一个有序数组。这个过程分为以下几个步骤：</p><ol><li><strong>分割数组</strong>： 将待排序的数组分成两个子数组，通常是平均分割。这一步持续递归，直到每个子数组只包含一个元素。</li><li><strong>递归排序</strong>： 递归地对左子数组和右子数组进行排序，直到它们都变成有序数组。</li><li><strong>合并数组</strong>： 将已排序的左子数组和右子数组合并成一个有序数组。合并的过程中，逐个比较左右两个数组的元素，并将较小的元素添加到结果数组中，直到两个数组都为空。</li><li><strong>返回结果</strong>： 最终得到一个完全排序好的数组。</li></ol><p>归并排序的关键在于合并过程，也就是如何将两个有序数组合并成一个有序数组。这一过程保持了相等元素的相对顺序，因此归并排序是一种稳定的排序算法。</p><h3 id="归并排序的示例"><a href="#归并排序的示例" class="headerlink" title="归并排序的示例"></a>归并排序的示例</h3><p>通过一个示例来理解归并排序的工作原理。假设我们有一个整数数组 [5, 2, 9, 3, 4]，我们希望按升序排序它。</p><ol><li><strong>分割数组</strong>： 首先将数组分成两个子数组 [5, 2] 和 [9, 3, 4]。</li><li><strong>递归排序</strong>： 分别对左子数组 [5, 2] 和右子数组 [9, 3, 4] 递归地应用归并排序。<ul><li>对左子数组 [5, 2] 进行归并排序，得到 [2, 5]。</li><li>对右子数组 [9, 3, 4] 进行归并排序，得到 [3, 4, 9]。</li></ul></li><li><strong>合并数组</strong>： 合并已排序的左子数组 [2, 5] 和右子数组 [3, 4, 9]。<ul><li>比较左右两个数组的首元素，选择较小的元素 2，将其添加到结果数组。</li><li>继续比较，选择 3，将其添加到结果数组。</li><li>接着选择 4、5、9，按顺序添加到结果数组。</li></ul></li><li><strong>返回结果</strong>： 最终，得到排序后的数组 [2, 3, 4, 5, 9]。</li></ol><h3 id="归并排序的时间复杂度"><a href="#归并排序的时间复杂度" class="headerlink" title="归并排序的时间复杂度"></a>归并排序的时间复杂度</h3><p>归并排序的时间复杂度非常稳定，始终为O(n*log(n))，其中n是数组的长度。这使得它适用于大型数据集和对稳定性有要求的情况。</p><p>尽管归并排序的时间复杂度相对较高，但它的性能稳定，对于各种数据集都表现出色。此外，归并排序是一种外部排序的重要算法，用于处理大型文件和数据库。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是归并排序的示例代码，分别使用Python、Go、Java和C语言编写。</p><p><strong>Python 归并排序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    mid = <span class="built_in">len</span>(arr) // <span class="number">2</span></span><br><span class="line">    left = arr[:mid]</span><br><span class="line">    right = arr[mid:]</span><br><span class="line"></span><br><span class="line">    left = merge_sort(left)</span><br><span class="line">    right = merge_sort(right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">left, right</span>):</span><br><span class="line">    result = []</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt; right[j]:</span><br><span class="line">            result.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    result.extend(left[i:])</span><br><span class="line">    result.extend(right[j:])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">sorted_arr = merge_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的数组:&quot;</span>, sorted_arr)</span><br></pre></td></tr></table></figure><p><strong>Go 归并排序</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mid := <span class="built_in">len</span>(arr) / <span class="number">2</span></span><br><span class="line">    left := arr[:mid]</span><br><span class="line">    right := arr[mid:]</span><br><span class="line"></span><br><span class="line">    left = mergeSort(left)</span><br><span class="line">    right = mergeSort(right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(left, right []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    result := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(left) &amp;&amp; j &lt; <span class="built_in">len</span>(right) &#123;</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt; right[j] &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, left[i])</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, right[j])</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = <span class="built_in">append</span>(result, left[i:]...)</span><br><span class="line">    result = <span class="built_in">append</span>(result, right[j:]...)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    sorted_arr := mergeSort(arr)</span><br><span class="line">    fmt.Println(<span class="string">&quot;排序后的数组:&quot;</span>, sorted_arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 归并排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            mergeSort(arr, left, mid);</span><br><span class="line">            mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">            merge(arr, left, mid, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> mid - left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> right - mid;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] leftArray = <span class="keyword">new</span> <span class="title class_">int</span>[n1];</span><br><span class="line">        <span class="type">int</span>[] rightArray = <span class="keyword">new</span> <span class="title class_">int</span>[n2];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n1; i++) &#123;</span><br><span class="line">            leftArray[i] = arr[left + i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n2; i++) &#123;</span><br><span class="line">            rightArray[i] = arr[mid + <span class="number">1</span> + i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftArray[i] &lt;= rightArray[j]) &#123;</span><br><span class="line">                arr[k] = leftArray[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[k] = rightArray[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">            arr[k] = leftArray[i];</span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">            arr[k] = rightArray[j];</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;排序后的数组: &quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C 语言 归并排序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n1 = mid - left + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n2 = right - mid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> leftArray[n1], rightArray[n2];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++) &#123;</span><br><span class="line">        leftArray[i] = arr[left + i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n2; i++) &#123;</span><br><span class="line">        rightArray[i] = arr[mid + <span class="number">1</span> + i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftArray[i] &lt;= rightArray[j]) &#123;</span><br><span class="line">            arr[k] = leftArray[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = rightArray[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">        arr[k] = leftArray[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">        arr[k] = rightArray[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(arr, left, mid);</span><br><span class="line">        mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    mergeSort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上示例代码展示了不同编程语言中的归并排序算法实现。这些示例帮助你理解归并排序的工作原理，并提供了可供参考和使用的代码示例。归并排序是一种稳定且高效的排序算法，适用于各种应用场景，特别适合对大型数据集进行排序。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;归并排序（Merge Sort）是一种高效的、基于分治法的排序算法，它的稳定性和性能使其成为常用的排序方法之一。本文将详细介绍归并排序的工作原理，提供示例和Python、Go、Java以及C语言的实现代码。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>十大排序算法（四） - 快速排序算法</title>
    <link href="http://example.com/2023/09/13/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2023/09/13/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2023-09-13T13:26:17.000Z</published>
    <updated>2023-09-16T09:28:21.777Z</updated>
    
    <content type="html"><![CDATA[<p>快速排序（Quick Sort）是一种高效的、分治法的排序算法，它在实际应用中被广泛采用，因为其性能优越。本文将详细介绍快速排序的工作原理，提供示例和Python、Go、Java以及C语言的实现代码。</p><span id="more"></span><h3 id="快速排序的基本思想"><a href="#快速排序的基本思想" class="headerlink" title="快速排序的基本思想"></a>快速排序的基本思想</h3><p>快速排序的核心思想是通过选择一个基准元素，将数组划分为两个子数组：小于基准的子数组和大于基准的子数组。然后，递归地对这两个子数组进行排序，最后将它们合并起来，完成整个排序过程。</p><p>以下是快速排序的详细步骤：</p><ol><li><strong>选择基准元素</strong>： 从待排序的数组中选择一个基准元素。通常，我们选择第一个元素，但也可以使用其他策略，如随机选择。</li><li><strong>划分数组</strong>： 将数组中的元素按照与基准元素的比较结果划分为两个子数组，一个包含小于基准的元素，另一个包含大于基准的元素。</li><li><strong>递归排序</strong>： 对划分后的子数组递归地应用快速排序算法，分别排序小于基准的子数组和大于基准的子数组。</li><li><strong>合并结果</strong>： 最后，将已排序的子数组合并起来，形成最终有序的数组。</li></ol><p>快速排序的关键在于划分步骤，也就是如何选择基准元素和将元素分配到子数组的过程。这一过程的高效性使得快速排序在大多数情况下表现出色。</p><h3 id="快速排序的示例"><a href="#快速排序的示例" class="headerlink" title="快速排序的示例"></a>快速排序的示例</h3><p>让我们通过一个示例来理解快速排序的工作原理。假设我们有一个整数数组 [5, 2, 9, 3, 4]，我们希望按升序排序它。</p><ol><li><strong>选择基准元素</strong>： 我们选择第一个元素 5 作为基准。</li><li><strong>划分数组</strong>： 我们遍历数组并将小于等于基准的元素放在左边，大于基准的元素放在右边。在这个示例中，划分后的结果是 [2, 3, 4] [5] [9]。</li><li><strong>递归排序</strong>： 我们对左边的子数组 [2, 3, 4] 和右边的子数组 [9] 分别应用快速排序。</li><li><strong>合并结果</strong>： 最终，将左边的子数组 [2, 3, 4]、基准元素 5 和右边的子数组 [9] 合并起来，得到 [2, 3, 4, 5, 9]，这就是排序后的数组。</li></ol><h3 id="快速排序的时间复杂度"><a href="#快速排序的时间复杂度" class="headerlink" title="快速排序的时间复杂度"></a>快速排序的时间复杂度</h3><p>快速排序通常具有较快的平均运行时间，并且在许多情况下表现优异。其平均时间复杂度为O(n*log(n))，其中n是数组的长度。在最坏情况下，时间复杂度为O(n^2)，但这种情况较少发生，并且通过随机选择基准元素或使用三取样划分等方法可以避免。</p><p>与其他排序算法相比，快速排序通常更快，尤其是在处理大型数据集时。它是许多标准库中的默认排序算法，如Python的sorted()函数和Java的Arrays.sort()方法。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是快速排序的示例代码，分别使用Python、Go、Java和C语言编写。</p><p><strong>Python 快速排序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    pivot = arr[<span class="number">0</span>]</span><br><span class="line">    less = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> x &lt;= pivot]</span><br><span class="line">    greater = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> x &gt; pivot]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> quick_sort(less) + [pivot] + quick_sort(greater)</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">sorted_arr = quick_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的数组:&quot;</span>, sorted_arr)</span><br></pre></td></tr></table></figure><p><strong>Go 快速排序</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pivot := arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> less, greater []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> arr[<span class="number">1</span>:] &#123;</span><br><span class="line">        <span class="keyword">if</span> v &lt;= pivot &#123;</span><br><span class="line">            less = <span class="built_in">append</span>(less, v)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            greater = <span class="built_in">append</span>(greater, v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    less = quickSort(less)</span><br><span class="line">    greater = quickSort(greater)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(<span class="built_in">append</span>(less, pivot), greater...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    sorted_arr := quickSort(arr)</span><br><span class="line">    fmt.Println(<span class="string">&quot;排序后的数组:&quot;</span>, sorted_arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 快速排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> partition(arr, low, high);</span><br><span class="line">            quickSort(arr, low, pivotIndex - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, pivotIndex + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[low];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> low + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> high;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; arr[left] &lt;= pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; arr[right] &gt;= pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">                arr[left] = arr[right];</span><br><span class="line">                arr[right] = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[low];</span><br><span class="line">        arr[low] = arr[right];</span><br><span class="line">        arr[right] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;排序后的数组: &quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C 语言 快速排序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[low];</span><br><span class="line">    <span class="type">int</span> left = low + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = high;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; arr[left] &lt;= pivot) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; arr[right] &gt;= pivot) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">            swap(&amp;arr[left], &amp;arr[right]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(&amp;arr[low], &amp;arr[right]);</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pivotIndex = partition(arr, low, high);</span><br><span class="line">        quickSort(arr, low, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pivotIndex + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上示例代码展示了不同编程语言中的快速排序算法实现。这些示例帮助你理解快速排序的工作原理，并提供了可供参考和使用的代码示例。无论使用哪种编程语言，快速排序都是一种高效的排序算法，适用于各种应用场景。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;快速排序（Quick Sort）是一种高效的、分治法的排序算法，它在实际应用中被广泛采用，因为其性能优越。本文将详细介绍快速排序的工作原理，提供示例和Python、Go、Java以及C语言的实现代码。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>十大排序算法（三） - 插入排序算法</title>
    <link href="http://example.com/2023/09/13/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2023/09/13/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2023-09-13T13:21:22.000Z</published>
    <updated>2023-09-16T09:27:51.404Z</updated>
    
    <content type="html"><![CDATA[<p>排序算法是计算机科学中的基础概念，它们用于对数据集合进行有序排列。插入排序（Insertion Sort）是其中一种简单而有效的排序算法。本文将详细介绍插入排序的工作原理，并提供Python、Go、Java和C语言的示例代码。</p><span id="more"></span><h3 id="插入排序的基本思想"><a href="#插入排序的基本思想" class="headerlink" title="插入排序的基本思想"></a>插入排序的基本思想</h3><p>插入排序的基本思想是将数据分成已排序和未排序两部分，初始时已排序部分只包含第一个元素，而未排序部分包含其他元素。然后，它从未排序部分依次选择元素，将其插入到已排序部分的合适位置，直到所有元素都在已排序部分。</p><p>让我们通过一个简单的示例来理解插入排序的工作原理。假设我们有一个整数数组 [5, 2, 9, 3, 4]，我们希望按升序排序它。</p><ol><li><strong>初始状态</strong>： 首先，已排序部分只包含第一个元素 5，未排序部分包含其他元素 [2, 9, 3, 4]。</li><li><strong>第一次插入</strong>： 从未排序部分选择第一个元素 2，将它与已排序部分的 5 比较。因为 2 &lt; 5，所以 2 插入到 5 的前面，得到 [2, 5] 和 [9, 3, 4]。</li><li><strong>第二次插入</strong>： 继续选择未排序部分的第一个元素 9，将它与已排序部分的 5 和 2 比较。由于 9 &gt; 5，不需要交换。已排序部分保持不变 [2, 5]，未排序部分为 [3, 4]。</li><li><strong>继续插入</strong>： 依此类推，依次选择未排序部分的元素并插入到已排序部分的正确位置。最终，数组被完全排序成 [2, 3, 4, 5, 9]。</li></ol><p>插入排序的关键在于将元素逐个插入到已排序部分，并确保已排序部分始终保持升序。</p><h3 id="插入排序的时间复杂度"><a href="#插入排序的时间复杂度" class="headerlink" title="插入排序的时间复杂度"></a>插入排序的时间复杂度</h3><p>插入排序的时间复杂度取决于输入数据的顺序。在最好的情况下，即数据已经按升序排列，插入排序的时间复杂度为O(n)，其中n是数组的长度。这是因为在最好情况下，不需要执行元素交换，只需遍历一次数组。</p><p>在最坏的情况下，即数据逆序排列，插入排序的时间复杂度为O(n^2)，因为每个元素都需要与已排序部分的所有元素进行比较和移动。</p><p>插入排序在小型数据集上通常表现良好，但对于大型数据集，更高效的排序算法可能更合适。</p><h3 id="插入排序的应用场景"><a href="#插入排序的应用场景" class="headerlink" title="插入排序的应用场景"></a>插入排序的应用场景</h3><p>尽管插入排序不如一些高级排序算法那样高效，但它仍然有一些应用场景：</p><ol><li><strong>小型数据集</strong>： 插入排序在处理小型数据集时性能良好，因为其常数因子较低。</li><li><strong>部分有序数据</strong>： 如果数据集已经部分有序，插入排序的性能会较好，因为不需要多次交换元素。</li><li><strong>稳定性要求</strong>： 插入排序是一种稳定的排序算法，可以保持相同元素的相对位置。</li><li><strong>在线排序</strong>： 插入排序可以应用于在线排序场景，即数据不一次性全部可用，而是逐个元素到达。</li></ol><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是插入排序的示例代码，分别使用Python、Go、Java和C语言编写。</p><p><strong>Python 插入排序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        key = arr[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> key &lt; arr[j]:</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = key</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">insertion_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的数组:&quot;</span>, arr)</span><br></pre></td></tr></table></figure><p><strong>Go 插入排序</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertionSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        key := arr[i]</span><br><span class="line">        j := i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; key &lt; arr[j] &#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j]</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = key</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    insertionSort(arr)</span><br><span class="line">    fmt.Println(<span class="string">&quot;排序后的数组:&quot;</span>, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 插入排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; key &lt; arr[j]) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + <span class="number">1</span>] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        insertionSort(arr);</span><br><span class="line">        System.out.print(<span class="string">&quot;排序后的数组: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C 语言 插入排序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> key = arr[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; key &lt; arr[j]) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    insertionSort(arr, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些示例代码演示了插入排序的工作原理，并提供了Python、Go、Java和C语言的不同语言版本的实现。插入排序虽然简单，但在一些特定情况下是一种有效的排序算法，特别适合处理小型数据集或部分有序的数据。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;排序算法是计算机科学中的基础概念，它们用于对数据集合进行有序排列。插入排序（Insertion Sort）是其中一种简单而有效的排序算法。本文将详细介绍插入排序的工作原理，并提供Python、Go、Java和C语言的示例代码。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>十大排序算法（二） - 选择排序算法</title>
    <link href="http://example.com/2023/09/11/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2023/09/11/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2023-09-11T13:42:42.000Z</published>
    <updated>2023-09-16T09:28:08.981Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机科学中，排序是一个基本而重要的问题。排序算法有许多种，其中之一是选择排序（Selection Sort）。本文将深入介绍选择排序的工作原理，讨论其时间复杂度，以及提供Python、Go、Java和C语言的示例代码。</p><span id="more"></span><h3 id="选择排序的基本思想"><a href="#选择排序的基本思想" class="headerlink" title="选择排序的基本思想"></a>选择排序的基本思想</h3><p>选择排序是一种比较排序算法，其基本思想是将数组分为已排序和未排序两部分。在每一次迭代中，从未排序部分中选择最小（或最大）的元素，将其放入已排序部分的末尾。这个过程不断迭代，直到整个数组都有序。</p><p>为了更好地理解选择排序，让我们通过一个简单的示例来演示其工作原理。假设我们有一个整数数组 [5, 2, 9, 3, 4]，我们希望按升序排序它。</p><ol><li><strong>第一次选择</strong>： 初始时，整个数组都被视为未排序部分。我们找到未排序部分中的最小元素 2，然后将其与已排序部分的末尾交换。数组变为 [2, 5, 9, 3, 4]，已排序部分为 2，未排序部分为 [5, 9, 3, 4]。</li><li><strong>第二次选择</strong>： 现在，我们在未排序部分 [5, 9, 3, 4] 中找到最小元素 3，将其与已排序部分的末尾交换。数组变为 [2, 3, 9, 5, 4]，已排序部分为 2, 3，未排序部分为 [9, 5, 4]。</li><li><strong>第三次选择</strong>： 继续这个过程，我们找到未排序部分中的最小元素 4，将其与已排序部分的末尾交换。数组变为 [2, 3, 4, 5, 9]，已排序部分为 2, 3, 4，未排序部分为 [5, 9]。</li><li><strong>完成排序</strong>： 最后，未排序部分只剩下两个元素 [5, 9]，我们将它们依次加入已排序部分，得到完全有序的数组 [2, 3, 4, 5, 9]。</li></ol><p>这个过程不断迭代，每一次迭代都会将未排序部分中的最小元素添加到已排序部分，最终得到完全有序的数组。</p><h3 id="选择排序的时间复杂度"><a href="#选择排序的时间复杂度" class="headerlink" title="选择排序的时间复杂度"></a>选择排序的时间复杂度</h3><p>选择排序的时间复杂度在任何情况下都为O(n^2)，其中n是数组的长度。这是因为在每一次迭代中，都需要在未排序部分中查找最小元素，这需要进行n次比较。虽然选择排序的时间复杂度较高，但它的优点是不需要额外的内存空间，是一种稳定的排序算法。</p><h3 id="选择排序的应用场景"><a href="#选择排序的应用场景" class="headerlink" title="选择排序的应用场景"></a>选择排序的应用场景</h3><p>尽管选择排序不是最高效的排序算法，但它在某些情况下仍然有用：</p><ol><li><strong>小型数据集</strong>: 在处理小型数据集时，选择排序可能比其他复杂的排序算法更具可读性和实现简单性。</li><li><strong>内存有限的情况</strong>: 选择排序不需要额外的内存空间，适用于内存有限的环境。</li><li><strong>对稳定性有要求</strong>: 选择排序是一种稳定的排序算法，可以保持相同元素的相对位置。</li></ol><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是选择排序的示例代码，分别使用Python、Go、Java和C语言编写。</p><p><strong>python代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selection_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[min_index]:</span><br><span class="line">                min_index = j</span><br><span class="line">        arr[i], arr[min_index] = arr[min_index], arr[i]</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">selection_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的数组:&quot;</span>, arr)</span><br></pre></td></tr></table></figure><p><strong>Go代码</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectionSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        minIndex := i</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[minIndex] &#123;</span><br><span class="line">                minIndex = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i], arr[minIndex] = arr[minIndex], arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    selectionSort(arr)</span><br><span class="line">    fmt.Println(<span class="string">&quot;排序后的数组:&quot;</span>, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[minIndex];</span><br><span class="line">            arr[minIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        selectionSort(arr);</span><br><span class="line">        System.out.print(<span class="string">&quot;排序后的数组: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    selectionSort(arr, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>这些示例代码演示了选择排序的工作原理，并提供了Python、Go、Java和C语言的不同语言版本的实现。选择排序是一种简单但不够高效的排序算法，通常在处理小型数据集或对稳定性要求较高的情况下使用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在计算机科学中，排序是一个基本而重要的问题。排序算法有许多种，其中之一是选择排序（Selection Sort）。本文将深入介绍选择排序的工作原理，讨论其时间复杂度，以及提供Python、Go、Java和C语言的示例代码。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>十大排序算法（一） - 冒泡排序算法</title>
    <link href="http://example.com/2023/09/10/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2023/09/10/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2023-09-10T01:27:48.000Z</published>
    <updated>2023-09-16T09:28:02.600Z</updated>
    
    <content type="html"><![CDATA[<p>排序算法是计算机科学中的重要主题，而冒泡排序（Bubble Sort）则是最简单的排序算法之一。尽管它在大型数据集上效率较低，但它的工作原理非常直观，是理解排序算法的绝佳起点。本文将深入探讨冒泡排序的工作原理、时间复杂度以及应用场景。</p><span id="more"></span><h3 id="冒泡排序的基本思想"><a href="#冒泡排序的基本思想" class="headerlink" title="冒泡排序的基本思想"></a>冒泡排序的基本思想</h3><p>冒泡排序的基本思想非常简单：通过不断比较相邻的两个元素，如果它们的顺序不正确，就交换它们，直到整个数组都排好序。这个过程类似于气泡在液体中上浮的过程，因此得名冒泡排序。</p><p>让我们通过一个简单的示例来理解冒泡排序的工作原理。假设有一个整数数组 [5, 2, 9, 3, 4]，我们希望按升序排序它。<br>1.<strong>第一次冒泡</strong>： 从数组的起始位置开始，比较相邻的元素，即 5 和 2。因为 5 &gt; 2，所以它们的顺序不正确，需要交换它们。数组变为 [2, 5, 9, 3, 4]。<br>2.<strong>第二次冒泡</strong>： 接下来，比较 5 和 9。由于它们的顺序正确，不需要交换。数组保持不变。<br>3.<strong>第三次冒泡</strong>： 继续比较 9 和 3，发现它们的顺序不正确，需要交换。数组变为 [2, 5, 3, 9, 4]。<br>4.<strong>第四次冒泡</strong>： 最后，比较 9 和 4，同样发现它们的顺序不正确，需要交换。数组变为 [2, 5, 3, 4, 9]。</p><p>这个过程会不断迭代，每次迭代都会将最大的元素“冒泡”到数组的末尾。在一次迭代中，通过多次比较和交换，最大的元素将沿着数组一路上浮到正确的位置。这就是为什么它被称为“冒泡”排序。</p><h3 id="冒泡排序的时间复杂度"><a href="#冒泡排序的时间复杂度" class="headerlink" title="冒泡排序的时间复杂度"></a>冒泡排序的时间复杂度</h3><p>虽然冒泡排序的思想简单，但它的时间复杂度并不理想。在最坏情况下，冒泡排序需要进行 n-1 次迭代（n 为数组长度），每次迭代都要比较相邻的元素并进行交换。因此，最坏情况下的时间复杂度为 O(n^2)。这使得冒泡排序在处理大型数据集时效率较低。</p><p>值得注意的是，在最佳情况下（数组已经有序），冒泡排序只需要一次迭代，因此时间复杂度为 O(n)。但这种情况很少发生。</p><h3 id="冒泡排序的应用场景"><a href="#冒泡排序的应用场景" class="headerlink" title="冒泡排序的应用场景"></a>冒泡排序的应用场景</h3><p>冒泡排序的性能相对较差，通常不推荐在实际应用中使用，特别是对于大型数据集。然而，由于其简单的原理，冒泡排序仍然有一些应用场景：</p><p>1.<strong>教育和学习</strong>： 冒泡排序是教授排序算法的良好起点，因为它易于理解和实现。<br>2.<strong>小型数据集</strong>： 在处理小型数据集时，冒泡排序的性能可能比其他复杂的排序算法更好。<br>3.<strong>已接近有序的数据</strong>： 如果数据集已经基本有序，冒泡排序可能比其他算法更有效。<br>4.<strong>排序算法的可视化</strong>： 冒泡排序可以用于排序算法可视化工具，帮助人们更好地理解排序过程。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>以下是冒泡排序的示例代码，分别使用Python、Go、Java和C语言编写。</p><p><strong>python代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n-i-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">bubble_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的数组:&quot;</span>, arr)</span><br></pre></td></tr></table></figure><p><strong>Go代码</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n-i<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] &#123;</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    bubbleSort(arr)</span><br><span class="line">    fmt.Println(<span class="string">&quot;排序后的数组:&quot;</span>, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        System.out.print(<span class="string">&quot;排序后的数组: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    bubbleSort(arr, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些示例代码展示了如何使用不同编程语言编写冒泡排序算法，它们都具有相同的工作原理，只是语法有所不同。冒泡排序是一种简单但不够高效的排序算法，通常在实际应用中使用更高效的排序算法。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>冒泡排序虽然不是最高效的排序算法，但它的简单性和直观性使它成为学习排序算法的良好起点。在实际应用中，通常会选择更高效的排序算法，特别是对于大型数据集。然而，了解冒泡排序的工作原理有助于理解更复杂的排序算法，并为算法设计提供宝贵的启示。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;排序算法是计算机科学中的重要主题，而冒泡排序（Bubble Sort）则是最简单的排序算法之一。尽管它在大型数据集上效率较低，但它的工作原理非常直观，是理解排序算法的绝佳起点。本文将深入探讨冒泡排序的工作原理、时间复杂度以及应用场景。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>解析排序算法：十大排序方法的工作原理与性能比较</title>
    <link href="http://example.com/2023/09/10/%E8%A7%A3%E6%9E%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"/>
    <id>http://example.com/2023/09/10/%E8%A7%A3%E6%9E%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/</id>
    <published>2023-09-10T01:17:10.000Z</published>
    <updated>2023-09-10T01:25:51.924Z</updated>
    
    <content type="html"><![CDATA[<p>当我们面临对数据进行排序的任务时，计算机科学家们开发了多种排序算法来满足不同的需求。这些排序算法各具特点，适用于不同规模和类型的数据集。在本文中，我们将介绍十大常见的排序算法，并讨论它们的工作原理、时间复杂度以及适用场景。</p><span id="more"></span><h3 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1. 冒泡排序（Bubble Sort）"></a>1. 冒泡排序（Bubble Sort）</h3><p>冒泡排序是最简单的排序算法之一。它反复比较相邻的两个元素，如果它们的顺序不正确，就交换它们，直到整个数组都排好序。冒泡排序的时间复杂度为O(n^2)，适用于小型数据集，但在大型数据集上效率较低。</p><h3 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2. 选择排序（Selection Sort）"></a>2. 选择排序（Selection Sort）</h3><p>选择排序将数组分为已排序和未排序两部分，然后选择未排序部分中的最小（或最大）元素，将其放在已排序部分的末尾。选择排序的时间复杂度也是O(n^2)，不稳定，适用于小型数据集。</p><h3 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3. 插入排序（Insertion Sort）"></a>3. 插入排序（Insertion Sort）</h3><p>插入排序将数组分为已排序和未排序两部分，然后逐个将未排序部分的元素插入已排序部分的正确位置。插入排序的时间复杂度也是O(n^2)，但在某些情况下比冒泡和选择排序更快，特别适用于部分有序的数据。</p><h3 id="4-快速排序（Quick-Sort）"><a href="#4-快速排序（Quick-Sort）" class="headerlink" title="4. 快速排序（Quick Sort）"></a>4. 快速排序（Quick Sort）</h3><p>快速排序是一种高效的分治排序算法。它选择一个元素作为“pivot”（基准），将数组分成两部分，然后递归地对这两部分进行排序。快速排序的平均时间复杂度为O(n*log(n))，但在最坏情况下可能达到O(n^2)。</p><h3 id="5-归并排序（Merge-Sort）"><a href="#5-归并排序（Merge-Sort）" class="headerlink" title="5. 归并排序（Merge Sort）"></a>5. 归并排序（Merge Sort）</h3><p>归并排序也是一种分治排序算法，它将数组逐步分成较小的子数组，然后合并这些子数组以获取最终排序结果。归并排序的时间复杂度为O(n*log(n))，具有稳定性。</p><h3 id="6-堆排序（Heap-Sort）"><a href="#6-堆排序（Heap-Sort）" class="headerlink" title="6. 堆排序（Heap Sort）"></a>6. 堆排序（Heap Sort）</h3><p>堆排序使用堆数据结构进行排序。它将数组看作二叉树，构建一个最大堆（或最小堆），然后逐个从堆中取出元素，得到有序序列。堆排序的时间复杂度为O(n*log(n))，不稳定。</p><h3 id="7-计数排序（Counting-Sort）"><a href="#7-计数排序（Counting-Sort）" class="headerlink" title="7. 计数排序（Counting Sort）"></a>7. 计数排序（Counting Sort）</h3><p>计数排序是一种非比较排序算法，适用于整数数据范围较小的情况。它通过统计每个元素出现的次数来进行排序，然后根据计数重新构建有序数组。时间复杂度为O(n+k)，其中k是整数范围。</p><h3 id="8-桶排序（Bucket-Sort）"><a href="#8-桶排序（Bucket-Sort）" class="headerlink" title="8. 桶排序（Bucket Sort）"></a>8. 桶排序（Bucket Sort）</h3><p>桶排序也是一种非比较排序算法，它将数据分为若干个桶，然后对每个桶内的数据进行排序，最后合并桶。桶排序适用于数据分布均匀的情况，平均时间复杂度为O(n+k)，其中k是桶的数量。</p><h3 id="9-基数排序（Radix-Sort）"><a href="#9-基数排序（Radix-Sort）" class="headerlink" title="9. 基数排序（Radix Sort）"></a>9. 基数排序（Radix Sort）</h3><p>基数排序是一种非比较排序算法，适用于整数或字符串排序。它按照元素的位数从低位到高位依次排序，每次排序使用稳定的排序算法。时间复杂度为O(d*(n+k))，其中d是最大位数，k是基数。</p><h3 id="10-希尔排序（Shell-Sort）"><a href="#10-希尔排序（Shell-Sort）" class="headerlink" title="10. 希尔排序（Shell Sort）"></a>10. 希尔排序（Shell Sort）</h3><p>希尔排序是一种改进的插入排序算法，它将数组分为若干个子序列，分别进行插入排序，然后逐渐减小子序列的间隔，最终完成排序。希尔排序的时间复杂度取决于间隔序列的选择，平均时间复杂度介于O(n*log(n))和O(n^2)之间。</p><p>每种排序算法都有其独特的优势和限制，选择合适的排序算法应根据数据集的规模、数据分布和性能需求来决定。了解这些排序算法的工作原理和特点可以帮助我们在实际应用中做出明智的选择，以满足不同排序任务的需求。无论是对小型数据集进行快速排序还是对大型数据集进行稳定排序，这十大排序算法都为我们提供了多种选择。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当我们面临对数据进行排序的任务时，计算机科学家们开发了多种排序算法来满足不同的需求。这些排序算法各具特点，适用于不同规模和类型的数据集。在本文中，我们将介绍十大常见的排序算法，并讨论它们的工作原理、时间复杂度以及适用场景。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
</feed>
